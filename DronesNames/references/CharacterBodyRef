// Decompiled with JetBrains decompiler
// Type: RoR2.CharacterBody
// Assembly: RoR2, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: ABEE4F3B-4618-4662-B4D0-BD0BC9965114
// Assembly location: D:\Games\SteamLibrary\steamapps\common\Risk of Rain 2\Risk of Rain 2_Data\Managed\RoR2.dll

using EntityStates;
using HG;
using RoR2.Audio;
using RoR2.Items;
using RoR2.Navigation;
using RoR2.Networking;
using RoR2.Projectile;
using RoR2.Skills;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.CompilerServices;
using Unity;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.Events;
using UnityEngine.Networking;
using UnityEngine.Serialization;

namespace RoR2
{
  [DisallowMultipleComponent]
  [RequireComponent(typeof (SkillLocator))]
  [RequireComponent(typeof (TeamComponent))]
  public class CharacterBodyRef : 
    NetworkBehaviour,
    ILifeBehavior,
    IDisplayNameProvider,
    IOnTakeDamageServerReceiver,
    IOnKilledOtherServerReceiver
  {
    [HideInInspector]
    [Tooltip("This is assigned to the prefab automatically by BodyCatalog at runtime. Do not set this value manually.")]
    public BodyIndex bodyIndex = BodyIndex.None;
    [Tooltip("The language token to use as the base name of this character.")]
    public string baseNameToken;
    public string subtitleNameToken;
    private BuffIndex[] activeBuffsList;
    private int activeBuffsListCount;
    private int[] buffs;
    private int eliteBuffCount;
    private List<CharacterBody.TimedBuff> timedBuffs = new List<CharacterBody.TimedBuff>();
    [NonSerialized]
    public int pendingTonicAfflictionCount;
    private GameObject warCryEffectInstance;
    [EnumMask(typeof (CharacterBody.BodyFlags))]
    public CharacterBody.BodyFlags bodyFlags;
    private NetworkInstanceId masterObjectId;
    private GameObject _masterObject;
    private CharacterMaster _master;
    private bool linkedToMaster;
    private bool disablingHurtBoxes;
    private EquipmentIndex previousEquipmentIndex = EquipmentIndex.None;
    private Transform transform;
    private SfxLocator sfxLocator;
    private static List<CharacterBody> instancesList = new List<CharacterBody>();
    public static readonly ReadOnlyCollection<CharacterBody> readOnlyInstancesList = new ReadOnlyCollection<CharacterBody>((IList<CharacterBody>) CharacterBody.instancesList);
    private bool _isSprinting;
    private const float outOfCombatDelay = 5f;
    private const float outOfDangerDelay = 7f;
    private float outOfCombatStopwatch;
    private float outOfDangerStopwatch;
    private bool _outOfDanger = true;
    private Vector3 previousPosition;
    private const float notMovingWait = 1f;
    private float notMovingStopwatch;
    public bool rootMotionInMainState;
    public float mainRootSpeed;
    public float baseMaxHealth;
    public float baseRegen;
    public float baseMaxShield;
    public float baseMoveSpeed;
    public float baseAcceleration;
    public float baseJumpPower;
    public float baseDamage;
    public float baseAttackSpeed;
    public float baseCrit;
    public float baseArmor;
    public float baseVisionDistance = float.PositiveInfinity;
    public int baseJumpCount = 1;
    public float sprintingSpeedMultiplier = 1.45f;
    public bool autoCalculateLevelStats;
    public float levelMaxHealth;
    public float levelRegen;
    public float levelMaxShield;
    public float levelMoveSpeed;
    public float levelJumpPower;
    public float levelDamage;
    public float levelAttackSpeed;
    public float levelCrit;
    public float levelArmor;
    private bool statsDirty;
    private float aimTimer;
    private const uint masterDirtyBit = 1;
    private const uint buffsDirtyBit = 2;
    private const uint outOfCombatBit = 4;
    private const uint outOfDangerBit = 8;
    private const uint sprintingBit = 16;
    private const uint allDirtyBits = 31;
    private HelfireController helfireController;
    private float helfireLifetime;
    private DamageTrail fireTrail;
    public bool wasLucky;
    private const float poisonballAngle = 25f;
    private const float poisonballDamageCoefficient = 1f;
    private const float poisonballRefreshTime = 6f;
    private float poisonballTimer;
    private const float lunarMissileDamageCoefficient = 0.3f;
    private const float lunarMissileRefreshTime = 10f;
    private const float lunarMissileDelayBetweenShots = 0.1f;
    private float lunarMissileRechargeTimer = 10f;
    private float lunarMissileTimerBetweenShots;
    private int remainingMissilesToFire;
    private GameObject lunarMissilePrefab;
    private GameObject timeBubbleWardInstance;
    private TemporaryVisualEffect engiShieldTempEffectInstance;
    private TemporaryVisualEffect bucklerShieldTempEffectInstance;
    private TemporaryVisualEffect slowDownTimeTempEffectInstance;
    private TemporaryVisualEffect crippleEffectInstance;
    private TemporaryVisualEffect tonicBuffEffectInstance;
    private TemporaryVisualEffect weakTempEffectInstance;
    private TemporaryVisualEffect energizedTempEffectInstance;
    private TemporaryVisualEffect barrierTempEffectInstance;
    private TemporaryVisualEffect nullifyStack1EffectInstance;
    private TemporaryVisualEffect nullifyStack2EffectInstance;
    private TemporaryVisualEffect nullifyStack3EffectInstance;
    private TemporaryVisualEffect regenBoostEffectInstance;
    private TemporaryVisualEffect elephantDefenseEffectInstance;
    private TemporaryVisualEffect healingDisabledEffectInstance;
    private TemporaryVisualEffect noCooldownEffectInstance;
    private TemporaryVisualEffect doppelgangerEffectInstance;
    private TemporaryVisualEffect deathmarkEffectInstance;
    private TemporaryVisualEffect crocoRegenEffectInstance;
    private TemporaryVisualEffect mercExposeEffectInstance;
    private TemporaryVisualEffect lifestealOnHitEffectInstance;
    private TemporaryVisualEffect teamWarCryEffectInstance;
    private TemporaryVisualEffect randomDamageEffectInstance;
    private TemporaryVisualEffect lunarGolemShieldEffectInstance;
    private TemporaryVisualEffect warbannerEffectInstance;
    private TemporaryVisualEffect teslaFieldEffectInstance;
    private TemporaryVisualEffect lunarSecondaryRootEffectInstance;
    private TemporaryVisualEffect lunarDetonatorEffectInstance;
    private TemporaryVisualEffect fruitingEffectInstance;
    private TemporaryVisualEffect mushroomVoidTempEffectInstance;
    private TemporaryVisualEffect bearVoidTempEffectInstance;
    private TemporaryVisualEffect outOfCombatArmorEffectInstance;
    private TemporaryVisualEffect voidFogMildEffectInstance;
    private TemporaryVisualEffect voidFogStrongEffectInstance;
    private TemporaryVisualEffect voidJailerSlowEffectInstance;
    private TemporaryVisualEffect voidRaidcrabWardWipeFogEffectInstance;
    [Tooltip("How long it takes for spread bloom to reset from full.")]
    public float spreadBloomDecayTime = 0.45f;
    [Tooltip("The spread bloom interpretation curve.")]
    public AnimationCurve spreadBloomCurve;
    private float spreadBloomInternal;
    [Tooltip("The crosshair prefab used for this body.")]
    [SerializeField]
    [FormerlySerializedAs("crosshairPrefab")]
    private GameObject _defaultCrosshairPrefab;
    [HideInInspector]
    public bool hideCrosshair;
    private const float multiKillMaxInterval = 1f;
    private float multiKillTimer;
    private const int multiKillThresholdForWarcry = 4;
    [Tooltip("The child transform to be used as the aiming origin.")]
    public Transform aimOriginTransform;
    [Tooltip("The hull size to use when pathfinding for this object.")]
    public HullClassification hullClassification;
    [Tooltip("The icon displayed for ally healthbars")]
    public Texture portraitIcon;
    [Tooltip("The main color of the body. Currently only used in the logbook.")]
    public Color bodyColor = Color.clear;
    [FormerlySerializedAs("isBoss")]
    [Tooltip("Whether or not this is a boss for dropping items on death.")]
    public bool isChampion;
    public VehicleSeat currentVehicle;
    [Tooltip("The pod prefab to use for handling this character's first-time spawn animation.")]
    public GameObject preferredPodPrefab;
    [Tooltip("The preferred state to use for handling the character's first-time spawn animation. Only used with no preferred pod prefab.")]
    public SerializableEntityStateType preferredInitialStateType = new SerializableEntityStateType(typeof (Uninitialized));
    public uint skinIndex;
    public string customKillTotalStatName;
    public Transform overrideCoreTransform;
    private static int kCmdCmdAddTimedBuff = -160178508;
    private static int kCmdCmdUpdateSprint;
    private static int kCmdCmdOnSkillActivated;
    private static int kRpcRpcBark;
    private static int kCmdCmdRequestVehicleEjection;
    private static int kRpcRpcUsePreferredInitialStateType;

    [RuntimeInitializeOnLoadMethod]
    private static void LoadCommonAssets() => CharacterBody.CommonAssets.Load();

    public string GetDisplayName() => Language.GetString(this.baseNameToken);

    public string GetSubtitle() => Language.GetString(this.subtitleNameToken);

    public string GetUserName()
    {
      string userName = "";
      if ((bool) (UnityEngine.Object) this.master)
      {
        PlayerCharacterMasterController component = this.master.GetComponent<PlayerCharacterMasterController>();
        if ((bool) (UnityEngine.Object) component)
          userName = component.GetDisplayName();
      }
      if (string.IsNullOrEmpty(userName))
        userName = this.GetDisplayName();
      return userName;
    }

    public string GetColoredUserName()
    {
      Color32 color = new Color32((byte) 127, (byte) 127, (byte) 127, byte.MaxValue);
      string str = (string) null;
      if ((bool) (UnityEngine.Object) this.master)
      {
        PlayerCharacterMasterController component1 = this.master.GetComponent<PlayerCharacterMasterController>();
        if ((bool) (UnityEngine.Object) component1)
        {
          GameObject networkUserObject = component1.networkUserObject;
          if ((bool) (UnityEngine.Object) networkUserObject)
          {
            NetworkUser component2 = networkUserObject.GetComponent<NetworkUser>();
            if ((bool) (UnityEngine.Object) component2)
            {
              color = component2.userColor;
              str = component2.userName;
            }
          }
        }
      }
      if (str == null)
        str = this.GetDisplayName();
      return Util.GenerateColoredString(str, color);
    }

    [Server]
    private void WriteBuffs(NetworkWriter writer)
    {
      if (!NetworkServer.active)
      {
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::WriteBuffs(UnityEngine.Networking.NetworkWriter)' called on client");
      }
      else
      {
        writer.Write((byte) this.activeBuffsListCount);
        for (int index = 0; index < this.activeBuffsListCount; ++index)
        {
          BuffIndex activeBuffs = this.activeBuffsList[index];
          BuffDef buffDef = BuffCatalog.GetBuffDef(activeBuffs);
          writer.WriteBuffIndex(activeBuffs);
          if (buffDef.canStack)
            writer.WritePackedUInt32((uint) this.buffs[(int) activeBuffs]);
        }
      }
    }

    [Client]
    private void ReadBuffs(NetworkReader reader)
    {
      if (!NetworkClient.active)
        Debug.LogWarning((object) "[Client] function 'System.Void RoR2.CharacterBody::ReadBuffs(UnityEngine.Networking.NetworkReader)' called on server");
      else if (this.activeBuffsList == null)
      {
        Debug.LogError((object) "Trying to ReadBuffs, but our activeBuffsList is null");
      }
      else
      {
        int activeBuffsIndexToCheck = 0;
        int num = (int) reader.ReadByte();
        BuffIndex buffIndex1 = BuffIndex.None;
        for (int index = 0; index < num; ++index)
        {
          BuffIndex buffIndex2 = reader.ReadBuffIndex();
          BuffDef buffDef = BuffCatalog.GetBuffDef(buffIndex2);
          if ((UnityEngine.Object) buffDef != (UnityEngine.Object) null)
          {
            int newCount = 1;
            if (buffDef.canStack)
              newCount = (int) reader.ReadPackedUInt32();
            if (newCount > 0 && !NetworkServer.active)
            {
              ZeroBuffIndexRange(buffIndex1 + 1, buffIndex2);
              this.SetBuffCount(buffIndex2, newCount);
            }
            buffIndex1 = buffIndex2;
          }
          else
            Debug.LogErrorFormat("No BuffDef for index {0}. body={1}, netID={2}", (object) buffIndex2, (object) this.gameObject, (object) this.netId);
        }
        if (NetworkServer.active)
          return;
        ZeroBuffIndexRange(buffIndex1 + 1, (BuffIndex) BuffCatalog.buffCount);

        void ZeroBuffIndexRange(BuffIndex start, BuffIndex end)
        {
          for (; activeBuffsIndexToCheck < this.activeBuffsListCount; ++activeBuffsIndexToCheck)
          {
            BuffIndex activeBuffs = this.activeBuffsList[activeBuffsIndexToCheck];
            if (end <= activeBuffs)
              break;
            if (start <= activeBuffs)
            {
              this.SetBuffCount(activeBuffs, 0);
              --activeBuffsIndexToCheck;
            }
          }
        }
      }
    }

    [Server]
    public void AddBuff(BuffIndex buffType)
    {
      if (!NetworkServer.active)
      {
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::AddBuff(RoR2.BuffIndex)' called on client");
      }
      else
      {
        if (buffType == BuffIndex.None)
          return;
        this.SetBuffCount(buffType, this.buffs[(int) buffType] + 1);
      }
    }

    [Server]
    [MethodImpl((MethodImplOptions) 256)]
    public void AddBuff(BuffDef buffDef)
    {
      if (!NetworkServer.active)
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::AddBuff(RoR2.BuffDef)' called on client");
      else
        this.AddBuff(buffDef != null ? buffDef.buffIndex : BuffIndex.None);
    }

    [Server]
    public void RemoveBuff(BuffIndex buffType)
    {
      if (!NetworkServer.active)
      {
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::RemoveBuff(RoR2.BuffIndex)' called on client");
      }
      else
      {
        if (buffType == BuffIndex.None)
          return;
        this.SetBuffCount(buffType, this.buffs[(int) buffType] - 1);
        if (buffType == RoR2Content.Buffs.MedkitHeal.buffIndex)
        {
          if (this.GetBuffCount(RoR2Content.Buffs.MedkitHeal.buffIndex) != 0)
            return;
          double num = (double) this.healthComponent.Heal(20f + this.maxHealth * 0.05f * (float) this.inventory.GetItemCount(RoR2Content.Items.Medkit), new ProcChainMask());
          EffectData effectData = new EffectData()
          {
            origin = this.transform.position
          };
          effectData.SetNetworkedObjectReference(this.gameObject);
          EffectManager.SpawnEffect(LegacyResourcesAPI.Load<GameObject>("Prefabs/Effects/MedkitHealEffect"), effectData, true);
        }
        else
        {
          if (buffType != RoR2Content.Buffs.TonicBuff.buffIndex || !(bool) (UnityEngine.Object) this.inventory || this.GetBuffCount(RoR2Content.Buffs.TonicBuff) != 0 || this.pendingTonicAfflictionCount <= 0)
            return;
          this.inventory.GiveItem(RoR2Content.Items.TonicAffliction, this.pendingTonicAfflictionCount);
          GenericPickupController.SendPickupMessage(this.master, PickupCatalog.FindPickupIndex(RoR2Content.Items.TonicAffliction.itemIndex));
          this.pendingTonicAfflictionCount = 0;
        }
      }
    }

    [Server]
    [MethodImpl((MethodImplOptions) 256)]
    public void RemoveBuff(BuffDef buffDef)
    {
      if (!NetworkServer.active)
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::RemoveBuff(RoR2.BuffDef)' called on client");
      else
        this.RemoveBuff(buffDef != null ? buffDef.buffIndex : BuffIndex.None);
    }

    private void SetBuffCount(BuffIndex buffType, int newCount)
    {
      ref int local = ref this.buffs[(int) buffType];
      if (newCount == local)
        return;
      int num = local;
      local = newCount;
      BuffDef buffDef = BuffCatalog.GetBuffDef(buffType);
      bool flag = true;
      if (!buffDef.canStack)
        flag = num == 0 != (newCount == 0);
      if (flag)
      {
        if (newCount == 0)
        {
          ArrayUtils.ArrayRemoveAt<BuffIndex>(this.activeBuffsList, ref this.activeBuffsListCount, Array.IndexOf<BuffIndex>(this.activeBuffsList, buffType));
          this.OnBuffFinalStackLost(buffDef);
        }
        else if (num == 0)
        {
          int position = 0;
          while (position < this.activeBuffsListCount && buffType >= this.activeBuffsList[position])
            ++position;
          ArrayUtils.ArrayInsert<BuffIndex>(ref this.activeBuffsList, ref this.activeBuffsListCount, position, in buffType);
          this.OnBuffFirstStackGained(buffDef);
        }
        if (NetworkServer.active)
          this.SetDirtyBit(2U);
      }
      this.statsDirty = true;
      if (!NetworkClient.active)
        return;
      this.OnClientBuffsChanged();
    }

    private void OnBuffFirstStackGained(BuffDef buffDef)
    {
      if (buffDef.isElite)
        ++this.eliteBuffCount;
      if ((UnityEngine.Object) buffDef == (UnityEngine.Object) RoR2Content.Buffs.Intangible)
        this.UpdateHurtBoxesEnabled();
      else if ((UnityEngine.Object) buffDef == (UnityEngine.Object) RoR2Content.Buffs.WarCryBuff)
      {
        if (!this.HasBuff(RoR2Content.Buffs.TeamWarCry))
          return;
        this.ClearTimedBuffs(RoR2Content.Buffs.TeamWarCry);
      }
      else if ((UnityEngine.Object) buffDef == (UnityEngine.Object) RoR2Content.Buffs.TeamWarCry)
      {
        if (!this.HasBuff(RoR2Content.Buffs.WarCryBuff))
          return;
        this.ClearTimedBuffs(RoR2Content.Buffs.WarCryBuff);
      }
      else
      {
        if (!((UnityEngine.Object) buffDef == (UnityEngine.Object) RoR2Content.Buffs.AffixEcho) || !NetworkServer.active)
          return;
        this.AddItemBehavior<CharacterBody.AffixEchoBehavior>(1);
      }
    }

    private void OnBuffFinalStackLost(BuffDef buffDef)
    {
      if (buffDef.isElite)
        --this.eliteBuffCount;
      if (buffDef.buffIndex == RoR2Content.Buffs.Intangible.buffIndex)
      {
        this.UpdateHurtBoxesEnabled();
      }
      else
      {
        if (!((UnityEngine.Object) buffDef == (UnityEngine.Object) RoR2Content.Buffs.AffixEcho) || !NetworkServer.active)
          return;
        this.AddItemBehavior<CharacterBody.AffixEchoBehavior>(0);
      }
    }

    [MethodImpl((MethodImplOptions) 256)]
    public int GetBuffCount(BuffIndex buffType) => ArrayUtils.GetSafe<int>(this.buffs, (int) buffType);

    [MethodImpl((MethodImplOptions) 256)]
    public int GetBuffCount(BuffDef buffDef) => this.GetBuffCount(buffDef != null ? buffDef.buffIndex : BuffIndex.None);

    [MethodImpl((MethodImplOptions) 256)]
    public bool HasBuff(BuffIndex buffType) => this.GetBuffCount(buffType) > 0;

    [MethodImpl((MethodImplOptions) 256)]
    public bool HasBuff(BuffDef buffDef) => this.HasBuff(buffDef != null ? buffDef.buffIndex : BuffIndex.None);

    public void AddTimedBuffAuthority(BuffIndex buffType, float duration)
    {
      if (NetworkServer.active)
        this.AddTimedBuff(buffType, duration);
      else
        this.CallCmdAddTimedBuff(buffType, duration);
    }

    [Command]
    public void CmdAddTimedBuff(BuffIndex buffType, float duration) => this.AddTimedBuff(buffType, duration);

    [Server]
    public void AddTimedBuff(BuffDef buffDef, float duration, int maxStacks)
    {
      if (!NetworkServer.active)
      {
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::AddTimedBuff(RoR2.BuffDef,System.Single,System.Int32)' called on client");
      }
      else
      {
        if (ImmuneToDebuffBehavior.OverrideDebuff(buffDef, this))
          return;
        if (this.GetBuffCount(buffDef) < maxStacks)
        {
          this.AddTimedBuff(buffDef, duration);
        }
        else
        {
          int index1 = -1;
          float num = duration;
          for (int index2 = 0; index2 < this.timedBuffs.Count; ++index2)
          {
            if (this.timedBuffs[index2].buffIndex == buffDef.buffIndex && (double) this.timedBuffs[index2].timer < (double) num)
            {
              index1 = index2;
              num = this.timedBuffs[index2].timer;
            }
          }
          if (index1 < 0)
            return;
          this.timedBuffs[index1].timer = duration;
        }
      }
    }

    [Server]
    public void AddTimedBuff(BuffDef buffDef, float duration)
    {
      if (!NetworkServer.active)
      {
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::AddTimedBuff(RoR2.BuffDef,System.Single)' called on client");
      }
      else
      {
        if (buffDef == null || ImmuneToDebuffBehavior.OverrideDebuff(buffDef, this))
          return;
        BuffIndex buffType = buffDef.buffIndex;
        if (buffType == BuffIndex.None)
          return;
        if ((UnityEngine.Object) buffDef == (UnityEngine.Object) RoR2Content.Buffs.AttackSpeedOnCrit)
        {
          int num1 = 1 + ((bool) (UnityEngine.Object) this.inventory ? this.inventory.GetItemCount(RoR2Content.Items.AttackSpeedOnCrit) : 0) * 2;
          int b = 0;
          int index1 = -1;
          float num2 = 999f;
          for (int index2 = 0; index2 < this.timedBuffs.Count; ++index2)
          {
            if (this.timedBuffs[index2].buffIndex == buffType)
            {
              ++b;
              if ((double) this.timedBuffs[index2].timer < (double) num2)
              {
                index1 = index2;
                num2 = this.timedBuffs[index2].timer;
              }
            }
          }
          if (b < num1)
          {
            this.timedBuffs.Add(new CharacterBody.TimedBuff()
            {
              buffIndex = buffType,
              timer = duration
            });
            this.AddBuff(buffType);
            ChildLocator component = this.modelLocator.modelTransform.GetComponent<ChildLocator>();
            if ((bool) (UnityEngine.Object) component)
            {
              Transform child1 = component.FindChild("HandL");
              Transform child2 = component.FindChild("HandR");
              GameObject effectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/Effects/WolfProcEffect");
              if ((bool) (UnityEngine.Object) child1)
                EffectManager.SimpleMuzzleFlash(effectPrefab, this.gameObject, "HandL", true);
              if ((bool) (UnityEngine.Object) child2)
                EffectManager.SimpleMuzzleFlash(effectPrefab, this.gameObject, "HandR", true);
            }
          }
          else if (index1 > -1)
            this.timedBuffs[index1].timer = duration;
          EntitySoundManager.EmitSoundServer(CharacterBody.CommonAssets.procCritAttackSpeedSounds[Mathf.Min(CharacterBody.CommonAssets.procCritAttackSpeedSounds.Length - 1, b)].index, this.networkIdentity);
        }
        else if ((UnityEngine.Object) buffDef == (UnityEngine.Object) RoR2Content.Buffs.BeetleJuice)
        {
          if (RefreshStacks() >= 10)
            return;
          this.timedBuffs.Add(new CharacterBody.TimedBuff()
          {
            buffIndex = buffType,
            timer = duration
          });
          this.AddBuff(buffType);
        }
        else if ((UnityEngine.Object) buffDef == (UnityEngine.Object) RoR2Content.Buffs.NullifyStack)
        {
          if (this.HasBuff(RoR2Content.Buffs.Nullified))
            return;
          int num = 0;
          for (int index = 0; index < this.timedBuffs.Count; ++index)
          {
            if (this.timedBuffs[index].buffIndex == buffType)
            {
              ++num;
              if ((double) this.timedBuffs[index].timer < (double) duration)
                this.timedBuffs[index].timer = duration;
            }
          }
          if (num < 2)
          {
            this.timedBuffs.Add(new CharacterBody.TimedBuff()
            {
              buffIndex = buffType,
              timer = duration
            });
            this.AddBuff(buffType);
          }
          else
          {
            this.ClearTimedBuffs(RoR2Content.Buffs.NullifyStack.buffIndex);
            this.AddTimedBuff(RoR2Content.Buffs.Nullified.buffIndex, 3f);
          }
        }
        else if ((UnityEngine.Object) buffDef == (UnityEngine.Object) RoR2Content.Buffs.AffixHauntedRecipient)
        {
          if (this.HasBuff(RoR2Content.Buffs.AffixHaunted))
            return;
          DefaultBehavior();
        }
        else if ((UnityEngine.Object) buffDef == (UnityEngine.Object) RoR2Content.Buffs.LunarDetonationCharge)
        {
          RefreshStacks();
          DefaultBehavior();
        }
        else if ((UnityEngine.Object) buffDef == (UnityEngine.Object) RoR2Content.Buffs.Overheat)
        {
          RefreshStacks();
          DefaultBehavior();
        }
        else
          DefaultBehavior();

        void DefaultBehavior()
        {
          bool flag = false;
          if (!buffDef.canStack)
          {
            for (int index = 0; index < this.timedBuffs.Count; ++index)
            {
              if (this.timedBuffs[index].buffIndex == buffType)
              {
                flag = true;
                this.timedBuffs[index].timer = Mathf.Max(this.timedBuffs[index].timer, duration);
                break;
              }
            }
          }
          if (!flag)
          {
            this.timedBuffs.Add(new CharacterBody.TimedBuff()
            {
              buffIndex = buffType,
              timer = duration
            });
            this.AddBuff(buffType);
          }
          if (!(bool) (UnityEngine.Object) buffDef.startSfx)
            return;
          EntitySoundManager.EmitSoundServer(buffDef.startSfx.index, this.networkIdentity);
        }

        int RefreshStacks()
        {
          int num = 0;
          for (int index = 0; index < this.timedBuffs.Count; ++index)
          {
            CharacterBody.TimedBuff timedBuff = this.timedBuffs[index];
            if (timedBuff.buffIndex == buffType)
            {
              ++num;
              if ((double) timedBuff.timer < (double) duration)
                timedBuff.timer = duration;
            }
          }
          return num;
        }
      }
    }

    [Server]
    [MethodImpl((MethodImplOptions) 256)]
    public void AddTimedBuff(BuffIndex buffIndex, float duration)
    {
      if (!NetworkServer.active)
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::AddTimedBuff(RoR2.BuffIndex,System.Single)' called on client");
      else
        this.AddTimedBuff(BuffCatalog.GetBuffDef(buffIndex), duration);
    }

    [Server]
    public void ClearTimedBuffs(BuffIndex buffType)
    {
      if (!NetworkServer.active)
      {
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::ClearTimedBuffs(RoR2.BuffIndex)' called on client");
      }
      else
      {
        for (int index = this.timedBuffs.Count - 1; index >= 0; --index)
        {
          CharacterBody.TimedBuff timedBuff = this.timedBuffs[index];
          if (timedBuff.buffIndex == buffType)
          {
            this.timedBuffs.RemoveAt(index);
            this.RemoveBuff(timedBuff.buffIndex);
          }
        }
      }
    }

    [Server]
    [MethodImpl((MethodImplOptions) 256)]
    public void ClearTimedBuffs(BuffDef buffDef)
    {
      if (!NetworkServer.active)
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::ClearTimedBuffs(RoR2.BuffDef)' called on client");
      else
        this.ClearTimedBuffs(buffDef != null ? buffDef.buffIndex : BuffIndex.None);
    }

    [Server]
    public void RemoveOldestTimedBuff(BuffIndex buffType)
    {
      if (!NetworkServer.active)
      {
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::RemoveOldestTimedBuff(RoR2.BuffIndex)' called on client");
      }
      else
      {
        float num = float.NegativeInfinity;
        int index1 = -1;
        for (int index2 = this.timedBuffs.Count - 1; index2 >= 0; --index2)
        {
          CharacterBody.TimedBuff timedBuff = this.timedBuffs[index2];
          if (timedBuff.buffIndex == buffType && (double) num < (double) timedBuff.timer)
          {
            num = timedBuff.timer;
            index1 = index2;
          }
        }
        if (index1 <= 0)
          return;
        this.timedBuffs.RemoveAt(index1);
        this.RemoveBuff(buffType);
      }
    }

    [Server]
    [MethodImpl((MethodImplOptions) 256)]
    public void RemoveOldestTimedBuff(BuffDef buffDef)
    {
      if (!NetworkServer.active)
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::RemoveOldestTimedBuff(RoR2.BuffDef)' called on client");
      else
        this.RemoveOldestTimedBuff(buffDef != null ? buffDef.buffIndex : BuffIndex.None);
    }

    [Server]
    private void UpdateBuffs(float deltaTime)
    {
      if (!NetworkServer.active)
      {
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::UpdateBuffs(System.Single)' called on client");
      }
      else
      {
        for (int index = this.timedBuffs.Count - 1; index >= 0; --index)
        {
          CharacterBody.TimedBuff timedBuff = this.timedBuffs[index];
          timedBuff.timer -= deltaTime;
          if ((double) timedBuff.timer <= 0.0)
          {
            this.timedBuffs.RemoveAt(index);
            this.RemoveBuff(timedBuff.buffIndex);
          }
        }
      }
    }

    [Client]
    private void OnClientBuffsChanged()
    {
      if (!NetworkClient.active)
      {
        Debug.LogWarning((object) "[Client] function 'System.Void RoR2.CharacterBody::OnClientBuffsChanged()' called on server");
      }
      else
      {
        int num = this.HasBuff(RoR2Content.Buffs.WarCryBuff) ? 1 : 0;
        if (num == 0 && (bool) (UnityEngine.Object) this.warCryEffectInstance)
          UnityEngine.Object.Destroy((UnityEngine.Object) this.warCryEffectInstance);
        if (num == 0 || (bool) (UnityEngine.Object) this.warCryEffectInstance)
          return;
        Transform parent = (bool) (UnityEngine.Object) this.mainHurtBox ? this.mainHurtBox.transform : this.transform;
        if (!(bool) (UnityEngine.Object) parent)
          return;
        this.warCryEffectInstance = UnityEngine.Object.Instantiate<GameObject>(LegacyResourcesAPI.Load<GameObject>("Prefabs/Effects/WarCryEffect"), parent.position, Quaternion.identity, parent);
      }
    }

    public CharacterMaster master => !(bool) (UnityEngine.Object) this.masterObject ? (CharacterMaster) null : this._master;

    public Inventory inventory { get; private set; }

    public bool isPlayerControlled { get; private set; }

    public float executeEliteHealthFraction { get; private set; }

    private void UpdateHurtBoxesEnabled()
    {
      bool flag = (bool) (UnityEngine.Object) this.inventory && this.inventory.GetItemCount(RoR2Content.Items.Ghost) > 0 || this.HasBuff(RoR2Content.Buffs.Intangible);
      if (flag == this.disablingHurtBoxes)
        return;
      if ((bool) (UnityEngine.Object) this.hurtBoxGroup)
      {
        if (flag)
          ++this.hurtBoxGroup.hurtBoxesDeactivatorCounter;
        else
          --this.hurtBoxGroup.hurtBoxesDeactivatorCounter;
      }
      this.disablingHurtBoxes = flag;
    }

    private void OnInventoryChanged()
    {
      EquipmentIndex currentEquipmentIndex = this.inventory.currentEquipmentIndex;
      if (currentEquipmentIndex != this.previousEquipmentIndex)
      {
        EquipmentDef equipmentDef1 = EquipmentCatalog.GetEquipmentDef(this.previousEquipmentIndex);
        EquipmentDef equipmentDef2 = EquipmentCatalog.GetEquipmentDef(currentEquipmentIndex);
        if ((UnityEngine.Object) equipmentDef1 != (UnityEngine.Object) null)
          this.OnEquipmentLost(equipmentDef1);
        if ((UnityEngine.Object) equipmentDef2 != (UnityEngine.Object) null)
          this.OnEquipmentGained(equipmentDef2);
        this.previousEquipmentIndex = currentEquipmentIndex;
      }
      this.statsDirty = true;
      this.UpdateHurtBoxesEnabled();
      this.AddItemBehavior<CharacterBody.AffixHauntedBehavior>(this.HasBuff(RoR2Content.Buffs.AffixHaunted) ? 1 : 0);
      this.AddItemBehavior<AffixEarthBehavior>(this.HasBuff(DLC1Content.Buffs.EliteEarth) ? 1 : 0);
      this.AddItemBehavior<AffixVoidBehavior>(this.HasBuff(DLC1Content.Buffs.EliteVoid) ? 1 : 0);
      if (NetworkServer.active)
      {
        this.AddItemBehavior<CharacterBody.QuestVolatileBatteryBehaviorServer>((UnityEngine.Object) this.inventory.GetEquipment((uint) this.inventory.activeEquipmentSlot).equipmentDef == (UnityEngine.Object) RoR2Content.Equipment.QuestVolatileBattery ? 1 : 0);
        this.AddItemBehavior<CharacterBody.ElementalRingsBehavior>(this.inventory.GetItemCount(RoR2Content.Items.IceRing) + this.inventory.GetItemCount(RoR2Content.Items.FireRing));
        this.AddItemBehavior<ElementalRingVoidBehavior>(this.inventory.GetItemCount(DLC1Content.Items.ElementalRingVoid));
        this.AddItemBehavior<OutOfCombatArmorBehavior>(this.inventory.GetItemCount(DLC1Content.Items.OutOfCombatArmor));
        this.AddItemBehavior<PrimarySkillShurikenBehavior>(this.inventory.GetItemCount(DLC1Content.Items.PrimarySkillShuriken));
        this.AddItemBehavior<MushroomVoidBehavior>(this.inventory.GetItemCount(DLC1Content.Items.MushroomVoid));
        this.AddItemBehavior<BearVoidBehavior>(this.inventory.GetItemCount(DLC1Content.Items.BearVoid));
        this.AddItemBehavior<LunarSunBehavior>(this.inventory.GetItemCount(DLC1Content.Items.LunarSun));
        this.AddItemBehavior<VoidMegaCrabItemBehavior>(this.inventory.GetItemCount(DLC1Content.Items.VoidMegaCrabItem));
        this.AddItemBehavior<DroneWeaponsBehavior>(this.inventory.GetItemCount(DLC1Content.Items.DroneWeapons));
        this.AddItemBehavior<DroneWeaponsBoostBehavior>(this.inventory.GetItemCount(DLC1Content.Items.DroneWeaponsBoost));
      }
      this.executeEliteHealthFraction = Util.ConvertAmplificationPercentageIntoReductionPercentage(13f * (float) this.inventory.GetItemCount(RoR2Content.Items.ExecuteLowHealthElite)) / 100f;
      if ((bool) (UnityEngine.Object) this.skillLocator)
      {
        this.ReplaceSkillIfItemPresent(this.skillLocator.primary, RoR2Content.Items.LunarPrimaryReplacement.itemIndex, CharacterBody.CommonAssets.lunarPrimaryReplacementSkillDef);
        this.ReplaceSkillIfItemPresent(this.skillLocator.secondary, RoR2Content.Items.LunarSecondaryReplacement.itemIndex, CharacterBody.CommonAssets.lunarSecondaryReplacementSkillDef);
        this.ReplaceSkillIfItemPresent(this.skillLocator.special, RoR2Content.Items.LunarSpecialReplacement.itemIndex, CharacterBody.CommonAssets.lunarSpecialReplacementSkillDef);
        this.ReplaceSkillIfItemPresent(this.skillLocator.utility, RoR2Content.Items.LunarUtilityReplacement.itemIndex, CharacterBody.CommonAssets.lunarUtilityReplacementSkillDef);
      }
      Action inventoryChanged = this.onInventoryChanged;
      if (inventoryChanged != null)
        inventoryChanged();
      Action<CharacterBody> inventoryChangedGlobal = CharacterBody.onBodyInventoryChangedGlobal;
      if (inventoryChangedGlobal == null)
        return;
      inventoryChangedGlobal(this);
    }

    private void ReplaceSkillIfItemPresent(
      GenericSkill skill,
      ItemIndex itemIndex,
      SkillDef skillDef)
    {
      if (!(bool) (UnityEngine.Object) skill)
        return;
      if (this.inventory.GetItemCount(itemIndex) > 0 && (bool) (UnityEngine.Object) skillDef)
        skill.SetSkillOverride((object) this, skillDef, GenericSkill.SkillOverridePriority.Replacement);
      else
        skill.UnsetSkillOverride((object) this, skillDef, GenericSkill.SkillOverridePriority.Replacement);
    }

    private void OnEquipmentLost(EquipmentDef equipmentDef)
    {
      if (!NetworkServer.active || equipmentDef.passiveBuffDef == null)
        return;
      this.RemoveBuff(equipmentDef.passiveBuffDef);
    }

    private void OnEquipmentGained(EquipmentDef equipmentDef)
    {
      if (!NetworkServer.active || equipmentDef.passiveBuffDef == null)
        return;
      this.AddBuff(equipmentDef.passiveBuffDef);
    }

    public event Action onInventoryChanged;

    public GameObject masterObject
    {
      get
      {
        if (!(bool) (UnityEngine.Object) this._masterObject)
        {
          if (NetworkServer.active)
            this._masterObject = NetworkServer.FindLocalObject(this.masterObjectId);
          else if (NetworkClient.active)
            this._masterObject = ClientScene.FindLocalObject(this.masterObjectId);
          this._master = (bool) (UnityEngine.Object) this._masterObject ? this._masterObject.GetComponent<CharacterMaster>() : (CharacterMaster) null;
          if ((bool) (UnityEngine.Object) this._master)
          {
            this.isPlayerControlled = (bool) (UnityEngine.Object) this._masterObject.GetComponent<PlayerCharacterMasterController>();
            if ((bool) (UnityEngine.Object) this.inventory)
              this.inventory.onInventoryChanged -= new Action(this.OnInventoryChanged);
            this.inventory = this._master.inventory;
            if ((bool) (UnityEngine.Object) this.inventory)
            {
              this.inventory.onInventoryChanged += new Action(this.OnInventoryChanged);
              this.OnInventoryChanged();
            }
            this.statsDirty = true;
          }
        }
        return this._masterObject;
      }
      set
      {
        this.masterObjectId = value.GetComponent<NetworkIdentity>().netId;
        this.statsDirty = true;
      }
    }

    private void UpdateMasterLink()
    {
      if (this.bodyFlags.HasFlag((Enum) CharacterBody.BodyFlags.Masterless) || this.linkedToMaster || !(bool) (UnityEngine.Object) this.master || !(bool) (UnityEngine.Object) this.master)
        return;
      this.master.OnBodyStart(this);
      this.linkedToMaster = true;
      this.skinIndex = this.master.loadout.bodyLoadoutManager.GetSkinIndex(this.bodyIndex);
    }

    public Rigidbody rigidbody { get; private set; }

    public NetworkIdentity networkIdentity { get; private set; }

    public CharacterMotor characterMotor { get; private set; }

    public CharacterDirection characterDirection { get; private set; }

    public TeamComponent teamComponent { get; private set; }

    public HealthComponent healthComponent { get; private set; }

    public EquipmentSlot equipmentSlot { get; private set; }

    public InputBankTest inputBank { get; private set; }

    public SkillLocator skillLocator { get; private set; }

    public ModelLocator modelLocator { get; private set; }

    public HurtBoxGroup hurtBoxGroup { get; private set; }

    public HurtBox mainHurtBox { get; private set; }

    public Transform coreTransform { get; private set; }

    [RuntimeInitializeOnLoadMethod]
    private static void Init() => CharacterBody.AssetReferences.Resolve();

    private void Awake()
    {
      this.transform = this.transform;
      this.rigidbody = this.GetComponent<Rigidbody>();
      this.networkIdentity = this.GetComponent<NetworkIdentity>();
      this.teamComponent = this.GetComponent<TeamComponent>();
      this.healthComponent = this.GetComponent<HealthComponent>();
      this.equipmentSlot = this.GetComponent<EquipmentSlot>();
      this.skillLocator = this.GetComponent<SkillLocator>();
      this.modelLocator = this.GetComponent<ModelLocator>();
      this.characterMotor = this.GetComponent<CharacterMotor>();
      this.characterDirection = this.GetComponent<CharacterDirection>();
      this.inputBank = this.GetComponent<InputBankTest>();
      this.sfxLocator = this.GetComponent<SfxLocator>();
      this.activeBuffsList = BuffCatalog.GetPerBuffBuffer<BuffIndex>();
      this.buffs = BuffCatalog.GetPerBuffBuffer<int>();
      if ((bool) (UnityEngine.Object) this.modelLocator)
      {
        this.modelLocator.onModelChanged += new Action<Transform>(this.OnModelChanged);
        this.OnModelChanged(this.modelLocator.modelTransform);
      }
      this.radius = 1f;
      CapsuleCollider component1 = this.GetComponent<CapsuleCollider>();
      if ((bool) (UnityEngine.Object) component1)
      {
        this.radius = component1.radius;
      }
      else
      {
        SphereCollider component2 = this.GetComponent<SphereCollider>();
        if ((bool) (UnityEngine.Object) component2)
          this.radius = component2.radius;
      }
      try
      {
        Action<CharacterBody> onBodyAwakeGlobal = CharacterBody.onBodyAwakeGlobal;
        if (onBodyAwakeGlobal == null)
          return;
        onBodyAwakeGlobal(this);
      }
      catch (Exception ex)
      {
        Debug.LogError((object) ex);
      }
    }

    private void OnModelChanged(Transform modelTransform)
    {
      this.hurtBoxGroup = (HurtBoxGroup) null;
      this.mainHurtBox = (HurtBox) null;
      this.coreTransform = this.transform;
      if ((bool) (UnityEngine.Object) modelTransform)
      {
        this.hurtBoxGroup = modelTransform.GetComponent<HurtBoxGroup>();
        if ((bool) (UnityEngine.Object) this.hurtBoxGroup)
        {
          this.mainHurtBox = this.hurtBoxGroup.mainHurtBox;
          if ((bool) (UnityEngine.Object) this.mainHurtBox)
            this.coreTransform = this.mainHurtBox.transform;
        }
      }
      if (!(bool) (UnityEngine.Object) this.overrideCoreTransform)
        return;
      this.coreTransform = this.overrideCoreTransform;
    }

    private void Start()
    {
      this.UpdateAuthority();
      this.localStartTime = Run.FixedTimeStamp.now;
      int num1 = (this.bodyFlags & CharacterBody.BodyFlags.Masterless) > CharacterBody.BodyFlags.None ? 1 : 0;
      this.outOfCombatStopwatch = float.PositiveInfinity;
      this.outOfDangerStopwatch = float.PositiveInfinity;
      this.notMovingStopwatch = 0.0f;
      if (NetworkServer.active)
      {
        this.outOfCombat = true;
        this.outOfDanger = true;
      }
      this.RecalculateStats();
      this.UpdateMasterLink();
      if (num1 != 0)
        this.healthComponent.Networkhealth = this.maxHealth;
      if ((bool) (UnityEngine.Object) this.sfxLocator && this.healthComponent.alive)
      {
        int num2 = (int) Util.PlaySound(this.sfxLocator.aliveLoopStart, this.gameObject);
      }
      Action<CharacterBody> onBodyStartGlobal = CharacterBody.onBodyStartGlobal;
      if (onBodyStartGlobal == null)
        return;
      onBodyStartGlobal(this);
    }

    public void Update() => this.UpdateSpreadBloom(Time.deltaTime);

    public void FixedUpdate()
    {
      this.outOfCombatStopwatch += Time.fixedDeltaTime;
      this.outOfDangerStopwatch += Time.fixedDeltaTime;
      this.aimTimer = Mathf.Max(this.aimTimer - Time.fixedDeltaTime, 0.0f);
      if (NetworkServer.active)
        this.UpdateMultiKill(Time.fixedDeltaTime);
      this.UpdateMasterLink();
      bool outOfCombat = this.outOfCombat;
      bool flag1 = outOfCombat;
      if (NetworkServer.active || this.hasEffectiveAuthority)
      {
        flag1 = (double) this.outOfCombatStopwatch >= 5.0;
        if (this.outOfCombat != flag1)
        {
          if (NetworkServer.active)
            this.SetDirtyBit(4U);
          this.outOfCombat = flag1;
          this.statsDirty = true;
        }
      }
      if (NetworkServer.active)
      {
        this.UpdateBuffs(Time.fixedDeltaTime);
        bool flag2 = (double) this.outOfDangerStopwatch >= 7.0;
        bool outOfDanger = this.outOfDanger;
        bool flag3 = outOfCombat & outOfDanger;
        int num1 = flag1 & flag2 ? 1 : 0;
        if (this.outOfDanger != flag2)
        {
          this.SetDirtyBit(8U);
          this.outOfDanger = flag2;
          this.statsDirty = true;
        }
        if (num1 != 0 && !flag3)
          this.OnOutOfCombatAndDangerServer();
        Vector3 position = this.transform.position;
        float num2 = 0.1f * Time.fixedDeltaTime;
        if ((double) (position - this.previousPosition).sqrMagnitude <= (double) num2 * (double) num2)
          this.notMovingStopwatch += Time.fixedDeltaTime;
        else
          this.notMovingStopwatch = 0.0f;
        this.previousPosition = position;
        this.UpdateHelfire();
        this.UpdateAffixPoison(Time.fixedDeltaTime);
        this.UpdateAffixLunar(Time.fixedDeltaTime);
      }
      if (this.statsDirty)
        this.RecalculateStats();
      this.UpdateFireTrail();
    }

    public void OnDeathStart()
    {
      this.enabled = false;
      if ((bool) (UnityEngine.Object) this.sfxLocator)
      {
        int num = (int) Util.PlaySound(this.sfxLocator.aliveLoopStop, this.gameObject);
      }
      if (NetworkServer.active && (bool) (UnityEngine.Object) this.currentVehicle)
        this.currentVehicle.EjectPassenger(this.gameObject);
      if ((bool) (UnityEngine.Object) this.master)
        this.master.OnBodyDeath(this);
      ModelLocator component1 = this.GetComponent<ModelLocator>();
      if (!(bool) (UnityEngine.Object) component1)
        return;
      Transform modelTransform = component1.modelTransform;
      if (!(bool) (UnityEngine.Object) modelTransform)
        return;
      CharacterModel component2 = modelTransform.GetComponent<CharacterModel>();
      if (!(bool) (UnityEngine.Object) component2)
        return;
      component2.OnDeath();
    }

    public void OnTakeDamageServer(DamageReport damageReport)
    {
      if ((double) damageReport.damageDealt > 0.0)
        this.outOfDangerStopwatch = 0.0f;
      if (!(bool) (UnityEngine.Object) this.master)
        return;
      this.master.OnBodyDamaged(damageReport);
    }

    public event Action<GenericSkill> onSkillActivatedServer;

    public event Action<GenericSkill> onSkillActivatedAuthority;

    public void OnSkillActivated(GenericSkill skill)
    {
      if (skill.isCombatSkill)
        this.outOfCombatStopwatch = 0.0f;
      if (this.hasEffectiveAuthority)
      {
        Action<GenericSkill> activatedAuthority = this.onSkillActivatedAuthority;
        if (activatedAuthority != null)
          activatedAuthority(skill);
      }
      if (NetworkServer.active)
      {
        Action<GenericSkill> skillActivatedServer = this.onSkillActivatedServer;
        if (skillActivatedServer == null)
          return;
        skillActivatedServer(skill);
      }
      else
        this.CallCmdOnSkillActivated((sbyte) this.skillLocator.FindSkillSlot(skill));
    }

    public void OnDestroy()
    {
      try
      {
        Action<CharacterBody> bodyDestroyGlobal = CharacterBody.onBodyDestroyGlobal;
        if (bodyDestroyGlobal != null)
          bodyDestroyGlobal(this);
      }
      catch (Exception ex)
      {
        Debug.LogError((object) ex);
      }
      if ((bool) (UnityEngine.Object) this.sfxLocator)
      {
        int num = (int) Util.PlaySound(this.sfxLocator.aliveLoopStop, this.gameObject);
      }
      if (this.modelLocator != null)
        this.modelLocator.onModelChanged -= new Action<Transform>(this.OnModelChanged);
      if ((bool) (UnityEngine.Object) this.inventory)
        this.inventory.onInventoryChanged -= new Action(this.OnInventoryChanged);
      if (!(bool) (UnityEngine.Object) this.master)
        return;
      this.master.OnBodyDestroyed(this);
    }

    public float GetNormalizedThreatValue() => (bool) (UnityEngine.Object) Run.instance ? ((bool) (UnityEngine.Object) this.master ? (float) this.master.money : 0.0f) / Mathf.Pow(Run.instance.compensatedDifficultyCoefficient, 2f) : 0.0f;

    private void OnEnable() => CharacterBody.instancesList.Add(this);

    private void OnDisable() => CharacterBody.instancesList.Remove(this);

    private void OnValidate()
    {
      if (this.autoCalculateLevelStats)
        this.PerformAutoCalculateLevelStats();
      if (Application.isPlaying || this.bodyIndex == BodyIndex.None)
        return;
      this.bodyIndex = BodyIndex.None;
    }

    public static event Action<CharacterBody> onBodyAwakeGlobal;

    public static event Action<CharacterBody> onBodyDestroyGlobal;

    public static event Action<CharacterBody> onBodyStartGlobal;

    public static event Action<CharacterBody> onBodyInventoryChangedGlobal;

    public bool hasEffectiveAuthority { get; private set; }

    private void UpdateAuthority() => this.hasEffectiveAuthority = Util.HasEffectiveAuthority(this.gameObject);

    public override void OnStartAuthority() => this.UpdateAuthority();

    public override void OnStopAuthority() => this.UpdateAuthority();

    public bool isSprinting
    {
      get => this._isSprinting;
      set
      {
        if (this._isSprinting == value)
          return;
        this._isSprinting = value;
        this.RecalculateStats();
        if (value)
          this.OnSprintStart();
        else
          this.OnSprintStop();
        if (NetworkServer.active)
        {
          this.SetDirtyBit(16U);
        }
        else
        {
          if (!this.hasEffectiveAuthority)
            return;
          this.CallCmdUpdateSprint(value);
        }
      }
    }

    private void OnSprintStart()
    {
      if (!(bool) (UnityEngine.Object) this.sfxLocator)
        return;
      int num = (int) Util.PlaySound(this.sfxLocator.sprintLoopStart, this.gameObject);
    }

    private void OnSprintStop()
    {
      if (!(bool) (UnityEngine.Object) this.sfxLocator)
        return;
      int num = (int) Util.PlaySound(this.sfxLocator.sprintLoopStop, this.gameObject);
    }

    [Command]
    private void CmdUpdateSprint(bool newIsSprinting) => this.isSprinting = newIsSprinting;

    [Command]
    private void CmdOnSkillActivated(sbyte skillIndex) => this.OnSkillActivated(this.skillLocator.GetSkill((SkillSlot) skillIndex));

    public bool outOfCombat { get; private set; } = true;

    public bool outOfDanger
    {
      get => this._outOfDanger;
      private set
      {
        if (this._outOfDanger == value)
          return;
        this._outOfDanger = value;
        this.OnOutOfDangerChanged();
      }
    }

    private void OnOutOfDangerChanged()
    {
      if (!this.outOfDanger || (double) this.healthComponent.shield == (double) this.healthComponent.fullShield)
        return;
      int num = (int) Util.PlaySound("Play_item_proc_personal_shield_recharge", this.gameObject);
    }

    [Server]
    private void OnOutOfCombatAndDangerServer()
    {
      if (NetworkServer.active)
        return;
      Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::OnOutOfCombatAndDangerServer()' called on client");
    }

    [Server]
    public bool GetNotMoving()
    {
      if (NetworkServer.active)
        return (double) this.notMovingStopwatch >= 1.0;
      Debug.LogWarning((object) "[Server] function 'System.Boolean RoR2.CharacterBody::GetNotMoving()' called on client");
      return false;
    }

    public void PerformAutoCalculateLevelStats()
    {
      this.levelMaxHealth = Mathf.Round(this.baseMaxHealth * 0.3f);
      this.levelMaxShield = Mathf.Round(this.baseMaxShield * 0.3f);
      this.levelRegen = this.baseRegen * 0.2f;
      this.levelMoveSpeed = 0.0f;
      this.levelJumpPower = 0.0f;
      this.levelDamage = this.baseDamage * 0.2f;
      this.levelAttackSpeed = 0.0f;
      this.levelCrit = 0.0f;
      this.levelArmor = 0.0f;
    }

    public float experience { get; private set; }

    public float level { get; private set; }

    public float maxHealth { get; private set; }

    public float maxBarrier { get; private set; }

    public float barrierDecayRate { get; private set; }

    public float regen { get; private set; }

    public float maxShield { get; private set; }

    public float moveSpeed { get; private set; }

    public float acceleration { get; private set; }

    public float jumpPower { get; private set; }

    public int maxJumpCount { get; private set; }

    public float maxJumpHeight { get; private set; }

    public float damage { get; private set; }

    public float attackSpeed { get; private set; }

    public float crit { get; private set; }

    public float critMultiplier { get; private set; }

    public float bleedChance { get; private set; }

    public float armor { get; private set; }

    public float visionDistance { get; private set; }

    public float critHeal { get; private set; }

    public float cursePenalty { get; private set; }

    public bool hasOneShotProtection { get; private set; }

    public bool isGlass { get; private set; }

    public float oneShotProtectionFraction { get; private set; }

    public bool canPerformBackstab { get; private set; }

    public bool canReceiveBackstab { get; private set; }

    public void MarkAllStatsDirty() => this.statsDirty = true;

    public void RecalculateStats()
    {
      float level = this.level;
      long teamExperience = (long) TeamManager.instance.GetTeamExperience(this.teamComponent.teamIndex);
      float teamLevel = (float) TeamManager.instance.GetTeamLevel(this.teamComponent.teamIndex);
      int num1 = 0;
      int num2 = 0;
      int num3 = 0;
      int num4 = 0;
      int num5 = 0;
      int num6 = 0;
      int num7 = 0;
      int num8 = 0;
      int num9 = 0;
      int num10 = 0;
      int num11 = 0;
      int num12 = 0;
      int num13 = 0;
      int num14 = 0;
      int num15 = 0;
      int num16 = 0;
      int num17 = 0;
      int num18 = 0;
      int newBonusStockFromBody1 = 0;
      int newBonusStockFromBody2 = 0;
      int num19 = 0;
      int num20 = 0;
      int num21 = 0;
      int num22 = 0;
      int p1 = 0;
      int p2 = 0;
      int num23 = 0;
      int num24 = 0;
      int num25 = 0;
      int num26 = 0;
      int num27 = 0;
      int num28 = 0;
      int num29 = 0;
      int num30 = 0;
      int num31 = 0;
      int num32 = 0;
      int num33 = 0;
      int num34 = 0;
      int num35 = 0;
      int num36 = 0;
      int num37 = 0;
      int num38 = 0;
      int num39 = 0;
      int num40 = 0;
      int num41 = 0;
      int num42 = 0;
      int num43 = 0;
      int num44 = 0;
      EquipmentIndex equipmentIndex = EquipmentIndex.None;
      uint num45 = 0;
      if ((bool) (UnityEngine.Object) this.inventory)
      {
        num1 = this.inventory.GetItemCount(RoR2Content.Items.LevelBonus);
        num2 = this.inventory.GetItemCount(RoR2Content.Items.Infusion);
        num3 = this.inventory.GetItemCount(RoR2Content.Items.HealWhileSafe);
        num4 = this.inventory.GetItemCount(RoR2Content.Items.PersonalShield);
        num5 = this.inventory.GetItemCount(RoR2Content.Items.Hoof);
        num6 = this.inventory.GetItemCount(RoR2Content.Items.SprintOutOfCombat);
        num7 = this.inventory.GetItemCount(RoR2Content.Items.Feather);
        num8 = this.inventory.GetItemCount(RoR2Content.Items.Syringe);
        num9 = this.inventory.GetItemCount(RoR2Content.Items.CritGlasses);
        num10 = this.inventory.GetItemCount(RoR2Content.Items.AttackSpeedOnCrit);
        num11 = this.inventory.GetItemCount(JunkContent.Items.CooldownOnCrit);
        num12 = this.inventory.GetItemCount(RoR2Content.Items.HealOnCrit);
        num13 = this.inventory.GetItemCount(RoR2Content.Items.ShieldOnly);
        num14 = this.inventory.GetItemCount(RoR2Content.Items.AlienHead);
        num15 = this.inventory.GetItemCount(RoR2Content.Items.Knurl);
        num16 = this.inventory.GetItemCount(RoR2Content.Items.BoostHp);
        num17 = this.inventory.GetItemCount(JunkContent.Items.CritHeal);
        num18 = this.inventory.GetItemCount(RoR2Content.Items.SprintBonus);
        newBonusStockFromBody1 = this.inventory.GetItemCount(RoR2Content.Items.SecondarySkillMagazine);
        num19 = this.inventory.GetItemCount(RoR2Content.Items.SprintArmor);
        num20 = this.inventory.GetItemCount(RoR2Content.Items.UtilitySkillMagazine);
        num21 = this.inventory.GetItemCount(RoR2Content.Items.HealthDecay);
        p1 = this.inventory.GetItemCount(RoR2Content.Items.TonicAffliction);
        p2 = this.inventory.GetItemCount(RoR2Content.Items.LunarDagger);
        num22 = this.inventory.GetItemCount(RoR2Content.Items.DrizzlePlayerHelper);
        num23 = this.inventory.GetItemCount(RoR2Content.Items.MonsoonPlayerHelper);
        num24 = this.inventory.GetItemCount(RoR2Content.Items.Pearl);
        num25 = this.inventory.GetItemCount(RoR2Content.Items.ShinyPearl);
        num26 = this.inventory.GetItemCount(RoR2Content.Items.InvadingDoppelganger);
        num27 = this.inventory.GetItemCount(RoR2Content.Items.CutHp);
        num28 = this.inventory.GetItemCount(RoR2Content.Items.BoostAttackSpeed);
        num29 = this.inventory.GetItemCount(RoR2Content.Items.BleedOnHitAndExplode);
        num30 = this.inventory.GetItemCount(RoR2Content.Items.LunarBadLuck);
        num31 = this.inventory.GetItemCount(RoR2Content.Items.FlatHealth);
        num32 = this.inventory.GetItemCount(RoR2Content.Items.TeamSizeDamageBonus);
        num33 = this.inventory.GetItemCount(RoR2Content.Items.SummonedEcho);
        num34 = this.inventory.GetItemCount(RoR2Content.Items.UseAmbientLevel);
        newBonusStockFromBody2 = this.inventory.GetItemCount(DLC1Content.Items.EquipmentMagazineVoid);
        num38 = this.inventory.GetItemCount(DLC1Content.Items.HalfAttackSpeedHalfCooldowns);
        num39 = this.inventory.GetItemCount(DLC1Content.Items.HalfSpeedDoubleHealth);
        num35 = this.inventory.GetItemCount(RoR2Content.Items.BleedOnHit);
        num36 = this.inventory.GetItemCount(DLC1Content.Items.AttackSpeedAndMoveSpeed);
        num37 = this.inventory.GetItemCount(DLC1Content.Items.CritDamage);
        num40 = this.inventory.GetItemCount(DLC1Content.Items.ConvertCritChanceToCritDamage);
        num41 = this.inventory.GetItemCount(DLC1Content.Items.DroneWeaponsBoost);
        num42 = this.inventory.GetItemCount(DLC1Content.Items.MissileVoid);
        equipmentIndex = this.inventory.currentEquipmentIndex;
        num45 = this.inventory.infusionBonus;
        num43 = equipmentIndex == DLC1Content.Equipment.EliteVoidEquipment.equipmentIndex ? 1 : 0;
        num44 = this.inventory.GetItemCount(DLC1Content.Items.OutOfCombatArmor);
        this.inventory.GetItemCount(DLC1Content.Items.VoidmanPassiveItem);
      }
      this.level = teamLevel;
      if (num34 > 0)
        this.level = Math.Max(this.level, (float) Run.instance.ambientLevelFloor);
      this.level += (float) num1;
      EquipmentDef equipmentDef = EquipmentCatalog.GetEquipmentDef(equipmentIndex);
      float num46 = this.level - 1f;
      this.isElite = this.eliteBuffCount > 0;
      bool flag1 = this.HasBuff(RoR2Content.Buffs.TonicBuff);
      int num47 = this.HasBuff(RoR2Content.Buffs.Entangle) ? 1 : 0;
      bool flag2 = this.HasBuff(RoR2Content.Buffs.Nullified);
      bool flag3 = this.HasBuff(RoR2Content.Buffs.LunarSecondaryRoot);
      bool flag4 = this.teamComponent.teamIndex == TeamIndex.Player && RunArtifactManager.instance.IsArtifactEnabled(RoR2Content.Artifacts.glassArtifactDef);
      int num48 = num13 > 0 ? 1 : (this.HasBuff(RoR2Content.Buffs.AffixLunar) ? 1 : 0);
      bool flag5 = equipmentDef != null && equipmentDef == JunkContent.Equipment.EliteYellowEquipment;
      this.hasOneShotProtection = this.isPlayerControlled;
      int buffCount1 = this.GetBuffCount(RoR2Content.Buffs.BeetleJuice);
      this.isGlass = flag4 || p2 > 0;
      this.canPerformBackstab = (this.bodyFlags & CharacterBody.BodyFlags.HasBackstabPassive) == CharacterBody.BodyFlags.HasBackstabPassive;
      this.canReceiveBackstab = (this.bodyFlags & CharacterBody.BodyFlags.HasBackstabImmunity) != CharacterBody.BodyFlags.HasBackstabImmunity;
      float maxHealth = this.maxHealth;
      float maxShield = this.maxShield;
      float num49 = this.baseMaxHealth + this.levelMaxHealth * num46;
      float num50 = 1f + (float) num16 * 0.1f + (float) (num24 + num25) * 0.1f + (float) num43 * 0.5f + (float) num39 * 1f;
      if (num2 > 0)
        num49 += (float) num45;
      float num51 = (num49 + (float) num31 * 25f + (float) num15 * 40f) * num50 / (float) (num27 + 1);
      if (num26 > 0)
        num51 *= 10f;
      if (num33 > 0)
        num51 *= 0.1f;
      this.maxHealth = num51;
      float num52 = this.baseMaxShield + this.levelMaxShield * num46 + (float) num4 * 0.08f * this.maxHealth;
      if (this.HasBuff(RoR2Content.Buffs.EngiShield))
        num52 += this.maxHealth * 1f;
      if (this.HasBuff(JunkContent.Buffs.EngiTeamShield))
        num52 += this.maxHealth * 0.5f;
      if (num42 > 0)
        num52 += this.maxHealth * 0.1f;
      if (num48 != 0)
      {
        num52 += this.maxHealth * (float) (1.5 + (double) (num13 - 1) * 0.25);
        this.maxHealth = 1f;
      }
      if (this.HasBuff(RoR2Content.Buffs.AffixBlue))
      {
        this.maxHealth -= this.maxHealth * 0.5f;
        num52 += this.maxHealth;
      }
      this.maxShield = num52;
      double num53 = (double) this.baseRegen + (double) this.levelRegen * (double) num46;
      float num54 = (float) (1.0 + (double) num46 * 0.20000000298023224);
      float num55 = (float) num15 * 1.6f * num54;
      float num56 = (!this.outOfDanger || num3 <= 0 ? 0.0f : 3f * (float) num3) * num54;
      float num57 = (this.HasBuff(JunkContent.Buffs.MeatRegenBoost) ? 2f : 0.0f) * num54;
      float num58 = (float) ((double) this.GetBuffCount(RoR2Content.Buffs.CrocoRegen) * (double) this.maxHealth * 0.10000000149011612);
      float num59 = (float) num25 * 0.1f * num54;
      float num60 = 1f;
      if (num22 > 0)
        num60 += 0.5f;
      if (num23 > 0)
        num60 -= 0.4f;
      double num61 = (double) num55;
      float b = ((float) (num53 + num61) + num56 + num57 + num59) * num60;
      if (this.HasBuff(RoR2Content.Buffs.OnFire) || this.HasBuff(DLC1Content.Buffs.StrongerBurn))
        b = Mathf.Min(0.0f, b);
      float a = b + num58;
      if (num48 != 0)
        a = Mathf.Max(a, 0.0f);
      if (num21 > 0)
        a = Mathf.Min(a, 0.0f) - this.maxHealth / this.cursePenalty / (float) num21;
      this.regen = a;
      float num62 = this.baseMoveSpeed + this.levelMoveSpeed * num46;
      float num63 = 1f;
      if (flag5)
        num62 += 2f;
      if (this.isSprinting)
        num62 *= this.sprintingSpeedMultiplier;
      float num64 = num63 + (float) num5 * 0.14f + (float) num36 * 0.07f + (float) num25 * 0.1f + 0.25f * (float) this.GetBuffCount(DLC1Content.Buffs.KillMoveSpeed);
      if (this.teamComponent.teamIndex == TeamIndex.Monster && Run.instance.selectedDifficulty >= DifficultyIndex.Eclipse4)
        num64 += 0.4f;
      if (this.isSprinting && num18 > 0)
        num64 += 0.25f * (float) num18 / this.sprintingSpeedMultiplier;
      if (num6 > 0 && this.HasBuff(RoR2Content.Buffs.WhipBoost))
        num64 += (float) num6 * 0.3f;
      if (num33 > 0)
        num64 += 0.66f;
      if (this.HasBuff(RoR2Content.Buffs.BugWings))
        num64 += 0.2f;
      if (this.HasBuff(RoR2Content.Buffs.Warbanner))
        num64 += 0.3f;
      if (this.HasBuff(JunkContent.Buffs.EnrageAncientWisp))
        num64 += 0.4f;
      if (this.HasBuff(RoR2Content.Buffs.CloakSpeed))
        num64 += 0.4f;
      if (this.HasBuff(RoR2Content.Buffs.WarCryBuff) || this.HasBuff(RoR2Content.Buffs.TeamWarCry))
        num64 += 0.5f;
      if (this.HasBuff(JunkContent.Buffs.EngiTeamShield))
        num64 += 0.3f;
      if (this.HasBuff(RoR2Content.Buffs.AffixLunar))
        num64 += 0.3f;
      float num65 = 1f;
      if (this.HasBuff(RoR2Content.Buffs.Slow50))
        num65 += 0.5f;
      if (this.HasBuff(RoR2Content.Buffs.Slow60))
        num65 += 0.6f;
      if (this.HasBuff(RoR2Content.Buffs.Slow80))
        num65 += 0.8f;
      if (this.HasBuff(RoR2Content.Buffs.ClayGoo))
        num65 += 0.5f;
      if (this.HasBuff(JunkContent.Buffs.Slow30))
        num65 += 0.3f;
      if (this.HasBuff(RoR2Content.Buffs.Cripple))
        ++num65;
      if (this.HasBuff(DLC1Content.Buffs.JailerSlow))
        ++num65;
      float num66 = num65 + (float) num39 * 1f;
      float num67 = num62 * (num64 / num66);
      if (buffCount1 > 0)
        num67 *= (float) (1.0 - 0.05000000074505806 * (double) buffCount1);
      this.moveSpeed = num67;
      this.acceleration = this.moveSpeed / this.baseMoveSpeed * this.baseAcceleration;
      int num68 = flag2 ? 1 : 0;
      if ((num47 | num68 | (flag3 ? 1 : 0)) != 0)
      {
        this.moveSpeed = 0.0f;
        this.acceleration = 80f;
      }
      this.jumpPower = this.baseJumpPower + this.levelJumpPower * num46;
      this.maxJumpHeight = Trajectory.CalculateApex(this.jumpPower);
      this.maxJumpCount = this.baseJumpCount + num7;
      this.oneShotProtectionFraction = 0.1f;
      float num69 = this.baseDamage + this.levelDamage * num46;
      float num70 = 1f;
      int num71 = (bool) (UnityEngine.Object) this.inventory ? this.inventory.GetItemCount(RoR2Content.Items.BoostDamage) : 0;
      if (num71 > 0)
        num70 += (float) num71 * 0.1f;
      if (num32 > 0)
      {
        int num72 = Math.Max(TeamComponent.GetTeamMembers(this.teamComponent.teamIndex).Count - 1, 0);
        num70 += (float) (num72 * num32) * 1f;
      }
      if (buffCount1 > 0)
        num70 -= 0.05f * (float) buffCount1;
      if (this.HasBuff(JunkContent.Buffs.GoldEmpowered))
        ++num70;
      if (this.HasBuff(RoR2Content.Buffs.PowerBuff))
        num70 += 0.5f;
      float num73 = num70 + (float) num25 * 0.1f + (Mathf.Pow(2f, (float) p2) - 1f) - (float) num43 * 0.3f;
      float num74 = num69 * num73;
      if (num26 > 0)
        num74 *= 0.04f;
      if (flag4)
        num74 *= 5f;
      this.damage = num74;
      float num75 = this.baseAttackSpeed + this.levelAttackSpeed * num46;
      float num76 = 1f + (float) num28 * 0.1f + (float) num8 * 0.15f + (float) num36 * 0.075f + (float) num41 * 0.5f;
      if (flag5)
        num76 += 0.5f;
      float num77 = num76 + (float) this.GetBuffCount(RoR2Content.Buffs.AttackSpeedOnCrit) * 0.12f;
      if (this.HasBuff(RoR2Content.Buffs.Warbanner))
        num77 += 0.3f;
      if (this.HasBuff(RoR2Content.Buffs.Energized))
        num77 += 0.7f;
      if (this.HasBuff(RoR2Content.Buffs.WarCryBuff) || this.HasBuff(RoR2Content.Buffs.TeamWarCry))
        ++num77;
      float num78 = Mathf.Max((num77 + (float) num25 * 0.1f) / (float) (num38 + 1), 0.1f);
      float num79 = num75 * num78;
      if (buffCount1 > 0)
        num79 *= (float) (1.0 - 0.05000000074505806 * (double) buffCount1);
      this.attackSpeed = num79;
      this.critMultiplier = (float) (2.0 + 1.0 * (double) num37);
      float num80 = this.baseCrit + this.levelCrit * num46 + (float) num9 * 10f;
      if (num10 > 0)
        num80 += 5f;
      if (num29 > 0)
        num80 += 5f;
      if (num11 > 0)
        num80 += 5f;
      if (num12 > 0)
        num80 += 5f;
      if (num17 > 0)
        num80 += 5f;
      if (this.HasBuff(RoR2Content.Buffs.FullCrit))
        num80 += 100f;
      float num81 = num80 + (float) num25 * 10f;
      if (num40 == 0)
      {
        this.crit = num81;
      }
      else
      {
        this.critMultiplier += num81 * 0.01f;
        this.crit = 0.0f;
      }
      this.armor = this.baseArmor + this.levelArmor * num46;
      if (num25 > 0)
        this.armor *= (float) (1.0 + 0.10000000149011612 * (double) num25);
      this.armor += (float) num22 * 70f;
      this.armor += this.HasBuff(RoR2Content.Buffs.ArmorBoost) ? 200f : 0.0f;
      this.armor += this.HasBuff(RoR2Content.Buffs.SmallArmorBoost) ? 100f : 0.0f;
      this.armor += this.HasBuff(DLC1Content.Buffs.OutOfCombatArmorBuff) ? 100f * (float) num44 : 0.0f;
      this.armor += this.HasBuff(RoR2Content.Buffs.ElephantArmorBoost) ? 500f : 0.0f;
      this.armor += this.HasBuff(DLC1Content.Buffs.VoidSurvivorCorruptMode) ? 100f : 0.0f;
      if (this.HasBuff(RoR2Content.Buffs.Cripple))
        this.armor -= 20f;
      if (this.HasBuff(RoR2Content.Buffs.Pulverized))
        this.armor -= 60f;
      if (this.isSprinting && num19 > 0)
        this.armor += (float) (num19 * 30);
      this.armor -= (float) this.GetBuffCount(DLC1Content.Buffs.PermanentDebuff) * 2f;
      float num82 = 0.0f;
      if (num30 > 0)
        num82 += (float) (2.0 + 1.0 * (double) (num30 - 1));
      float num83 = 1f;
      if (this.HasBuff(JunkContent.Buffs.GoldEmpowered))
        num83 *= 0.25f;
      for (int index = 0; index < num14; ++index)
        num83 *= 0.75f;
      for (int index = 0; index < num38; ++index)
        num83 *= 0.5f;
      for (int index = 0; index < num41; ++index)
        num83 *= 0.5f;
      if (this.teamComponent.teamIndex == TeamIndex.Monster && Run.instance.selectedDifficulty >= DifficultyIndex.Eclipse7)
        num83 *= 0.5f;
      if (this.HasBuff(RoR2Content.Buffs.NoCooldowns))
        num83 = 0.0f;
      if ((bool) (UnityEngine.Object) this.skillLocator.primary)
      {
        this.skillLocator.primary.cooldownScale = num83;
        this.skillLocator.primary.flatCooldownReduction = num82;
      }
      if ((bool) (UnityEngine.Object) this.skillLocator.secondaryBonusStockSkill)
      {
        this.skillLocator.secondaryBonusStockSkill.cooldownScale = num83;
        this.skillLocator.secondaryBonusStockSkill.SetBonusStockFromBody(newBonusStockFromBody1);
        this.skillLocator.secondaryBonusStockSkill.flatCooldownReduction = num82;
      }
      if ((bool) (UnityEngine.Object) this.skillLocator.utilityBonusStockSkill)
      {
        float num84 = num83;
        if (num20 > 0)
          num84 *= 0.6666667f;
        this.skillLocator.utilityBonusStockSkill.cooldownScale = num84;
        this.skillLocator.utilityBonusStockSkill.flatCooldownReduction = num82;
        this.skillLocator.utilityBonusStockSkill.SetBonusStockFromBody(num20 * 2);
      }
      if ((bool) (UnityEngine.Object) this.skillLocator.specialBonusStockSkill)
      {
        this.skillLocator.specialBonusStockSkill.cooldownScale = num83;
        if (newBonusStockFromBody2 > 0)
          this.skillLocator.specialBonusStockSkill.cooldownScale *= 0.67f;
        this.skillLocator.specialBonusStockSkill.flatCooldownReduction = num82;
        this.skillLocator.specialBonusStockSkill.SetBonusStockFromBody(newBonusStockFromBody2);
      }
      this.critHeal = 0.0f;
      if (num17 > 0)
      {
        float crit = this.crit;
        this.crit /= (float) (num17 + 1);
        this.critHeal = crit - this.crit;
      }
      this.cursePenalty = 1f;
      if (p2 > 0)
        this.cursePenalty = Mathf.Pow(2f, (float) p2);
      if (flag4)
        this.cursePenalty *= 10f;
      int buffCount2 = this.GetBuffCount(RoR2Content.Buffs.PermanentCurse);
      if (buffCount2 > 0)
        this.cursePenalty += (float) buffCount2 * 0.01f;
      if (this.HasBuff(RoR2Content.Buffs.Weak))
      {
        this.armor -= 30f;
        this.damage *= 0.6f;
        this.moveSpeed *= 0.6f;
      }
      if (flag1)
      {
        this.maxHealth *= 1.5f;
        this.maxShield *= 1.5f;
        this.attackSpeed *= 1.7f;
        this.moveSpeed *= 1.3f;
        this.armor += 20f;
        this.damage *= 2f;
        this.regen *= 4f;
      }
      else if (p1 > 0)
      {
        float num85 = Mathf.Pow(0.95f, (float) p1);
        this.attackSpeed *= num85;
        this.moveSpeed *= num85;
        this.damage *= num85;
        this.regen *= num85;
        this.cursePenalty += 0.1f * (float) p1;
      }
      this.maxHealth /= this.cursePenalty;
      this.maxShield /= this.cursePenalty;
      this.oneShotProtectionFraction = Mathf.Max(0.0f, this.oneShotProtectionFraction - (float) (1.0 - 1.0 / (double) this.cursePenalty));
      this.maxBarrier = this.maxHealth + this.maxShield;
      this.barrierDecayRate = this.maxBarrier / 30f;
      if (NetworkServer.active)
      {
        float amount = this.maxHealth - maxHealth;
        float num86 = this.maxShield - maxShield;
        if ((double) amount > 0.0)
        {
          double num87 = (double) this.healthComponent.Heal(amount, new ProcChainMask(), false);
        }
        else if ((double) this.healthComponent.health > (double) this.maxHealth)
          this.healthComponent.Networkhealth = Mathf.Max(this.healthComponent.health + amount, this.maxHealth);
        if ((double) num86 > 0.0)
          this.healthComponent.RechargeShield(num86);
        else if ((double) this.healthComponent.shield > (double) this.maxShield)
          this.healthComponent.Networkshield = Mathf.Max(this.healthComponent.shield + num86, this.maxShield);
      }
      this.bleedChance = 10f * (float) num35;
      this.visionDistance = this.baseVisionDistance;
      if (this.HasBuff(DLC1Content.Buffs.Blinded))
        this.visionDistance = Mathf.Min(this.visionDistance, 15f);
      if ((double) this.level != (double) level)
        this.OnCalculatedLevelChanged(level, this.level);
      this.UpdateAllTemporaryVisualEffects();
      this.statsDirty = false;
    }

    public void OnTeamLevelChanged() => this.statsDirty = true;

    private void OnCalculatedLevelChanged(float oldLevel, float newLevel)
    {
      if ((double) newLevel <= (double) oldLevel)
        return;
      int num = Mathf.FloorToInt(oldLevel);
      if (Mathf.FloorToInt(newLevel) <= num || num == 0)
        return;
      this.OnLevelUp();
    }

    private void OnLevelUp() => GlobalEventManager.OnCharacterLevelUp(this);

    public void SetAimTimer(float duration) => this.aimTimer = duration;

    public bool shouldAim => (double) this.aimTimer > 0.0 && !this.isSprinting;

    public override void OnDeserialize(NetworkReader reader, bool initialState)
    {
      int num = (int) reader.ReadByte();
      if ((num & 1) != 0)
      {
        NetworkInstanceId networkInstanceId = reader.ReadNetworkId();
        if (networkInstanceId != this.masterObjectId)
        {
          this.masterObjectId = networkInstanceId;
          this.statsDirty = true;
        }
      }
      if ((num & 2) != 0)
        this.ReadBuffs(reader);
      if ((num & 4) != 0)
      {
        bool flag = reader.ReadBoolean();
        if (!this.hasEffectiveAuthority && flag != this.outOfCombat)
        {
          this.outOfCombat = flag;
          this.statsDirty = true;
        }
      }
      if ((num & 8) != 0)
      {
        bool flag = reader.ReadBoolean();
        if (flag != this.outOfDanger)
        {
          this.outOfDanger = flag;
          this.statsDirty = true;
        }
      }
      if ((num & 16) == 0)
        return;
      bool flag1 = reader.ReadBoolean();
      if (flag1 == this.isSprinting || this.hasEffectiveAuthority)
        return;
      this.statsDirty = true;
      this.isSprinting = flag1;
    }

    public override bool OnSerialize(NetworkWriter writer, bool initialState)
    {
      uint num1 = this.syncVarDirtyBits;
      if (initialState)
        num1 = 31U;
      int num2 = (num1 & 1U) > 0U ? 1 : 0;
      bool flag1 = (num1 & 2U) > 0U;
      bool flag2 = (num1 & 4U) > 0U;
      bool flag3 = (num1 & 8U) > 0U;
      bool flag4 = (num1 & 16U) > 0U;
      writer.Write((byte) num1);
      if (num2 != 0)
        writer.Write(this.masterObjectId);
      if (flag1)
        this.WriteBuffs(writer);
      if (flag2)
        writer.Write(this.outOfCombat);
      if (flag3)
        writer.Write(this.outOfDanger);
      if (flag4)
        writer.Write(this.isSprinting);
      return !initialState && num1 > 0U;
    }

    public T AddItemBehavior<T>(int stack) where T : CharacterBody.ItemBehavior
    {
      T obj = this.GetComponent<T>();
      if (stack > 0)
      {
        if (!(bool) (UnityEngine.Object) obj)
        {
          obj = this.gameObject.AddComponent<T>();
          obj.body = this;
          obj.enabled = true;
        }
        obj.stack = stack;
        return obj;
      }
      if ((bool) (UnityEngine.Object) obj)
        UnityEngine.Object.Destroy((UnityEngine.Object) obj);
      return default (T);
    }

    public int killCountServer { get; private set; }

    public void HandleOnKillEffectsServer(DamageReport damageReport)
    {
      ++this.killCountServer;
      this.AddMultiKill(1);
    }

    public void OnKilledOtherServer(DamageReport damageReport)
    {
    }

    public void AddHelfireDuration(float duration) => this.helfireLifetime = duration;

    [Server]
    private void UpdateHelfire()
    {
      if (!NetworkServer.active)
      {
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::UpdateHelfire()' called on client");
      }
      else
      {
        this.helfireLifetime -= Time.fixedDeltaTime;
        bool flag = false;
        if ((bool) (UnityEngine.Object) this.inventory)
          flag = this.inventory.GetItemCount(JunkContent.Items.BurnNearby) > 0 || (double) this.helfireLifetime > 0.0;
        if ((bool) (UnityEngine.Object) this.helfireController == flag)
          return;
        if (flag)
        {
          this.helfireController = UnityEngine.Object.Instantiate<GameObject>(LegacyResourcesAPI.Load<GameObject>("Prefabs/NetworkedObjects/HelfireController")).GetComponent<HelfireController>();
          this.helfireController.networkedBodyAttachment.AttachToGameObjectAndSpawn(this.gameObject);
        }
        else
        {
          UnityEngine.Object.Destroy((UnityEngine.Object) this.helfireController.gameObject);
          this.helfireController = (HelfireController) null;
        }
      }
    }

    private void UpdateFireTrail()
    {
      bool flag = this.HasBuff(RoR2Content.Buffs.AffixRed);
      if (flag != (bool) (UnityEngine.Object) this.fireTrail)
      {
        if (flag)
        {
          this.fireTrail = UnityEngine.Object.Instantiate<GameObject>(LegacyResourcesAPI.Load<GameObject>("Prefabs/FireTrail"), this.transform).GetComponent<DamageTrail>();
          this.fireTrail.transform.position = this.footPosition;
          this.fireTrail.owner = this.gameObject;
          this.fireTrail.radius *= this.radius;
        }
        else
        {
          UnityEngine.Object.Destroy((UnityEngine.Object) this.fireTrail.gameObject);
          this.fireTrail = (DamageTrail) null;
        }
      }
      if (!(bool) (UnityEngine.Object) this.fireTrail)
        return;
      this.fireTrail.damagePerSecond = this.damage * 1.5f;
    }

    private void UpdateAffixPoison(float deltaTime)
    {
      if (!this.HasBuff(RoR2Content.Buffs.AffixPoison))
        return;
      this.poisonballTimer += deltaTime;
      if ((double) this.poisonballTimer < 6.0)
        return;
      int num1 = 3 + (int) this.radius;
      this.poisonballTimer = 0.0f;
      Vector3 up = Vector3.up;
      float num2 = 360f / (float) num1;
      Vector3 normalized = Vector3.ProjectOnPlane(this.transform.forward, up).normalized;
      Vector3 vector3 = Vector3.RotateTowards(up, normalized, 5f * (float) Math.PI / 36f, float.PositiveInfinity);
      for (int index = 0; index < num1; ++index)
      {
        Vector3 forward = Quaternion.AngleAxis(num2 * (float) index, up) * vector3;
        ProjectileManager.instance.FireProjectile(LegacyResourcesAPI.Load<GameObject>("Prefabs/Projectiles/PoisonOrbProjectile"), this.corePosition, Util.QuaternionSafeLookRotation(forward), this.gameObject, this.damage * 1f, 0.0f, Util.CheckRoll(this.crit, this.master));
      }
    }

    private void UpdateAffixLunar(float deltaTime)
    {
      if (this.outOfCombat || !this.HasBuff(RoR2Content.Buffs.AffixLunar))
        return;
      this.lunarMissileRechargeTimer += deltaTime;
      this.lunarMissileTimerBetweenShots += deltaTime;
      int num1 = 4;
      if (!(bool) (UnityEngine.Object) this.lunarMissilePrefab)
        this.lunarMissilePrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/Projectiles/LunarMissileProjectile");
      if ((double) this.lunarMissileRechargeTimer >= 10.0)
      {
        this.lunarMissileRechargeTimer = 0.0f;
        this.remainingMissilesToFire += num1;
      }
      if (this.remainingMissilesToFire <= 0 || (double) this.lunarMissileTimerBetweenShots <= 0.10000000149011612)
        return;
      this.lunarMissileTimerBetweenShots = 0.0f;
      Vector3 vector3_1 = (bool) (UnityEngine.Object) this.inputBank ? this.inputBank.aimDirection : this.transform.forward;
      float num2 = 180f / (float) num1;
      float num3 = (float) (3.0 + (double) (int) this.radius * 1.0);
      float num4 = this.damage * 0.3f;
      Quaternion quaternion = Util.QuaternionSafeLookRotation(vector3_1);
      Vector3 vector3_2 = this.aimOrigin + Quaternion.AngleAxis((float) ((double) (this.remainingMissilesToFire - 1) * (double) num2 - (double) num2 * (double) (num1 - 1) / 2.0), vector3_1) * Vector3.up * num3;
      ProjectileManager.instance.FireProjectile(new FireProjectileInfo()
      {
        projectilePrefab = this.lunarMissilePrefab,
        position = vector3_2,
        rotation = quaternion,
        owner = this.gameObject,
        damage = num4,
        crit = Util.CheckRoll(this.crit, this.master),
        force = 200f
      });
      --this.remainingMissilesToFire;
    }

    public float bestFitRadius => Mathf.Max(this.radius, (bool) (UnityEngine.Object) this.characterMotor ? this.characterMotor.capsuleHeight : 1f);

    private void UpdateAllTemporaryVisualEffects()
    {
      int buffCount = this.GetBuffCount(RoR2Content.Buffs.NullifyStack);
      this.UpdateSingleTemporaryVisualEffect(ref this.engiShieldTempEffectInstance, CharacterBody.AssetReferences.engiShieldTempEffectPrefab, this.bestFitRadius, (double) this.healthComponent.shield > 0.0 && this.HasBuff(RoR2Content.Buffs.EngiShield));
      ref TemporaryVisualEffect local1 = ref this.bucklerShieldTempEffectInstance;
      GameObject tempEffectPrefab = CharacterBody.AssetReferences.bucklerShieldTempEffectPrefab;
      double radius1 = (double) this.radius;
      int num1;
      if (this.isSprinting)
      {
        Inventory inventory = this.inventory;
        num1 = inventory != null ? (inventory.GetItemCount(RoR2Content.Items.SprintArmor) > 0 ? 1 : 0) : 0;
      }
      else
        num1 = 0;
      this.UpdateSingleTemporaryVisualEffect(ref local1, tempEffectPrefab, (float) radius1, num1 != 0);
      this.UpdateSingleTemporaryVisualEffect(ref this.slowDownTimeTempEffectInstance, CharacterBody.AssetReferences.slowDownTimeTempEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.Slow60));
      this.UpdateSingleTemporaryVisualEffect(ref this.crippleEffectInstance, CharacterBody.AssetReferences.crippleEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.Cripple));
      this.UpdateSingleTemporaryVisualEffect(ref this.tonicBuffEffectInstance, CharacterBody.AssetReferences.tonicBuffEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.TonicBuff));
      this.UpdateSingleTemporaryVisualEffect(ref this.weakTempEffectInstance, CharacterBody.AssetReferences.weakTempEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.Weak));
      this.UpdateSingleTemporaryVisualEffect(ref this.energizedTempEffectInstance, CharacterBody.AssetReferences.energizedTempEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.Energized));
      this.UpdateSingleTemporaryVisualEffect(ref this.barrierTempEffectInstance, CharacterBody.AssetReferences.barrierTempEffectPrefab, this.bestFitRadius, (double) this.healthComponent.barrier > 0.0);
      this.UpdateSingleTemporaryVisualEffect(ref this.regenBoostEffectInstance, CharacterBody.AssetReferences.regenBoostEffectPrefab, this.bestFitRadius, this.HasBuff(JunkContent.Buffs.MeatRegenBoost));
      this.UpdateSingleTemporaryVisualEffect(ref this.elephantDefenseEffectInstance, CharacterBody.AssetReferences.elephantDefenseEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.ElephantArmorBoost));
      this.UpdateSingleTemporaryVisualEffect(ref this.healingDisabledEffectInstance, CharacterBody.AssetReferences.healingDisabledEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.HealingDisabled));
      this.UpdateSingleTemporaryVisualEffect(ref this.noCooldownEffectInstance, CharacterBody.AssetReferences.noCooldownEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.NoCooldowns), "Head");
      ref TemporaryVisualEffect local2 = ref this.doppelgangerEffectInstance;
      GameObject doppelgangerEffectPrefab = CharacterBody.AssetReferences.doppelgangerEffectPrefab;
      double radius2 = (double) this.radius;
      Inventory inventory1 = this.inventory;
      int num2 = inventory1 != null ? (inventory1.GetItemCount(RoR2Content.Items.InvadingDoppelganger) > 0 ? 1 : 0) : 0;
      this.UpdateSingleTemporaryVisualEffect(ref local2, doppelgangerEffectPrefab, (float) radius2, num2 != 0, "Head");
      this.UpdateSingleTemporaryVisualEffect(ref this.nullifyStack1EffectInstance, CharacterBody.AssetReferences.nullifyStack1EffectPrefab, this.radius, buffCount == 1);
      this.UpdateSingleTemporaryVisualEffect(ref this.nullifyStack2EffectInstance, CharacterBody.AssetReferences.nullifyStack2EffectPrefab, this.radius, buffCount == 2);
      this.UpdateSingleTemporaryVisualEffect(ref this.nullifyStack3EffectInstance, CharacterBody.AssetReferences.nullifyStack3EffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.Nullified));
      this.UpdateSingleTemporaryVisualEffect(ref this.deathmarkEffectInstance, CharacterBody.AssetReferences.deathmarkEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.DeathMark));
      this.UpdateSingleTemporaryVisualEffect(ref this.crocoRegenEffectInstance, CharacterBody.AssetReferences.crocoRegenEffectPrefab, this.bestFitRadius, this.HasBuff(RoR2Content.Buffs.CrocoRegen));
      this.UpdateSingleTemporaryVisualEffect(ref this.mercExposeEffectInstance, CharacterBody.AssetReferences.mercExposeEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.MercExpose));
      this.UpdateSingleTemporaryVisualEffect(ref this.lifestealOnHitEffectInstance, CharacterBody.AssetReferences.lifestealOnHitEffectPrefab, this.bestFitRadius, this.HasBuff(RoR2Content.Buffs.LifeSteal));
      this.UpdateSingleTemporaryVisualEffect(ref this.teamWarCryEffectInstance, CharacterBody.AssetReferences.teamWarCryEffectPrefab, this.bestFitRadius, this.HasBuff(RoR2Content.Buffs.TeamWarCry), "HeadCenter");
      this.UpdateSingleTemporaryVisualEffect(ref this.lunarGolemShieldEffectInstance, CharacterBody.AssetReferences.lunarGolemShieldEffectPrefab, this.bestFitRadius, this.HasBuff(RoR2Content.Buffs.LunarShell));
      this.UpdateSingleTemporaryVisualEffect(ref this.randomDamageEffectInstance, CharacterBody.AssetReferences.randomDamageEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.PowerBuff));
      this.UpdateSingleTemporaryVisualEffect(ref this.warbannerEffectInstance, CharacterBody.AssetReferences.warbannerEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.Warbanner));
      this.UpdateSingleTemporaryVisualEffect(ref this.teslaFieldEffectInstance, CharacterBody.AssetReferences.teslaFieldEffectPrefab, this.bestFitRadius, this.HasBuff(RoR2Content.Buffs.TeslaField));
      this.UpdateSingleTemporaryVisualEffect(ref this.lunarSecondaryRootEffectInstance, CharacterBody.AssetReferences.lunarSecondaryRootEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.LunarSecondaryRoot));
      this.UpdateSingleTemporaryVisualEffect(ref this.lunarDetonatorEffectInstance, CharacterBody.AssetReferences.lunarDetonatorEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.LunarDetonationCharge));
      this.UpdateSingleTemporaryVisualEffect(ref this.fruitingEffectInstance, CharacterBody.AssetReferences.fruitingEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.Fruiting));
      this.UpdateSingleTemporaryVisualEffect(ref this.mushroomVoidTempEffectInstance, CharacterBody.AssetReferences.mushroomVoidTempEffectPrefab, this.radius, this.HasBuff(DLC1Content.Buffs.MushroomVoidActive));
      this.UpdateSingleTemporaryVisualEffect(ref this.bearVoidTempEffectInstance, CharacterBody.AssetReferences.bearVoidTempEffectPrefab, this.radius, this.HasBuff(DLC1Content.Buffs.BearVoidReady));
      this.UpdateSingleTemporaryVisualEffect(ref this.outOfCombatArmorEffectInstance, CharacterBody.AssetReferences.outOfCombatArmorEffectPrefab, this.radius, this.HasBuff(DLC1Content.Buffs.OutOfCombatArmorBuff));
      this.UpdateSingleTemporaryVisualEffect(ref this.voidFogMildEffectInstance, CharacterBody.AssetReferences.voidFogMildEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.VoidFogMild));
      this.UpdateSingleTemporaryVisualEffect(ref this.voidFogStrongEffectInstance, CharacterBody.AssetReferences.voidFogStrongEffectPrefab, this.radius, this.HasBuff(RoR2Content.Buffs.VoidFogStrong));
      this.UpdateSingleTemporaryVisualEffect(ref this.voidRaidcrabWardWipeFogEffectInstance, CharacterBody.AssetReferences.voidRaidcrabWardWipeFogEffectPrefab, this.radius, this.HasBuff(DLC1Content.Buffs.VoidRaidCrabWardWipeFog));
      this.UpdateSingleTemporaryVisualEffect(ref this.voidJailerSlowEffectInstance, CharacterBody.AssetReferences.voidJailerSlowEffectPrefab, this.radius, this.HasBuff(DLC1Content.Buffs.JailerSlow));
    }

    private void UpdateSingleTemporaryVisualEffect(
      ref TemporaryVisualEffect tempEffect,
      string resourceString,
      float effectRadius,
      bool active,
      string childLocatorOverride = "")
    {
      bool flag = (UnityEngine.Object) tempEffect != (UnityEngine.Object) null;
      if (flag == active)
        return;
      if (active)
      {
        if (flag)
          return;
        GameObject gameObject = UnityEngine.Object.Instantiate<GameObject>(LegacyResourcesAPI.Load<GameObject>(resourceString), this.corePosition, Quaternion.identity);
        tempEffect = gameObject.GetComponent<TemporaryVisualEffect>();
        tempEffect.parentTransform = this.coreTransform;
        tempEffect.visualState = TemporaryVisualEffect.VisualState.Enter;
        tempEffect.healthComponent = this.healthComponent;
        tempEffect.radius = effectRadius;
        LocalCameraEffect component1 = gameObject.GetComponent<LocalCameraEffect>();
        if ((bool) (UnityEngine.Object) component1)
          component1.targetCharacter = this.gameObject;
        if (string.IsNullOrEmpty(childLocatorOverride))
          return;
        ChildLocator component2 = this.modelLocator?.modelTransform?.GetComponent<ChildLocator>();
        if (!(bool) (UnityEngine.Object) component2)
          return;
        Transform child = component2.FindChild(childLocatorOverride);
        if (!(bool) (UnityEngine.Object) child)
          return;
        tempEffect.parentTransform = child;
      }
      else
      {
        if (!(bool) (UnityEngine.Object) tempEffect)
          return;
        tempEffect.visualState = TemporaryVisualEffect.VisualState.Exit;
      }
    }

    private void UpdateSingleTemporaryVisualEffect(
      ref TemporaryVisualEffect tempEffect,
      GameObject tempEffectPrefab,
      float effectRadius,
      bool active,
      string childLocatorOverride = "")
    {
      bool flag = (UnityEngine.Object) tempEffect != (UnityEngine.Object) null;
      if (flag == active)
        return;
      if (active)
      {
        if (flag)
          return;
        if ((bool) (UnityEngine.Object) tempEffectPrefab)
        {
          GameObject gameObject = UnityEngine.Object.Instantiate<GameObject>(tempEffectPrefab, this.corePosition, Quaternion.identity);
          tempEffect = gameObject.GetComponent<TemporaryVisualEffect>();
          tempEffect.parentTransform = this.coreTransform;
          tempEffect.visualState = TemporaryVisualEffect.VisualState.Enter;
          tempEffect.healthComponent = this.healthComponent;
          tempEffect.radius = effectRadius;
          LocalCameraEffect component1 = gameObject.GetComponent<LocalCameraEffect>();
          if ((bool) (UnityEngine.Object) component1)
            component1.targetCharacter = this.gameObject;
          if (string.IsNullOrEmpty(childLocatorOverride))
            return;
          ChildLocator component2 = this.modelLocator?.modelTransform?.GetComponent<ChildLocator>();
          if (!(bool) (UnityEngine.Object) component2)
            return;
          Transform child = component2.FindChild(childLocatorOverride);
          if (!(bool) (UnityEngine.Object) child)
            return;
          tempEffect.parentTransform = child;
        }
        else
          Debug.LogError((object) "Can't instantiate null temporary visual effect");
      }
      else
      {
        if (!(bool) (UnityEngine.Object) tempEffect)
          return;
        tempEffect.visualState = TemporaryVisualEffect.VisualState.Exit;
      }
    }

    public bool hasCloakBuff => this.HasBuff(RoR2Content.Buffs.Cloak) || this.HasBuff(RoR2Content.Buffs.AffixHauntedRecipient);

    public VisibilityLevel GetVisibilityLevel(CharacterBody observer) => this.GetVisibilityLevel((bool) (UnityEngine.Object) observer ? observer.teamComponent.teamIndex : TeamIndex.None);

    public VisibilityLevel GetVisibilityLevel(TeamIndex observerTeam)
    {
      if (!this.hasCloakBuff)
        return VisibilityLevel.Visible;
      return this.teamComponent.teamIndex != observerTeam ? VisibilityLevel.Cloaked : VisibilityLevel.Revealed;
    }

    public void AddSpreadBloom(float value) => this.spreadBloomInternal = Mathf.Min(this.spreadBloomInternal + value, 1f);

    public void SetSpreadBloom(float value, bool canOnlyIncreaseBloom = true)
    {
      if (canOnlyIncreaseBloom)
        this.spreadBloomInternal = Mathf.Clamp(value, this.spreadBloomInternal, 1f);
      else
        this.spreadBloomInternal = Mathf.Min(value, 1f);
    }

    private void UpdateSpreadBloom(float dt) => this.spreadBloomInternal = Mathf.Max(this.spreadBloomInternal - 1f / this.spreadBloomDecayTime * dt, 0.0f);

    public float spreadBloomAngle => this.spreadBloomCurve.Evaluate(this.spreadBloomInternal);

    public GameObject defaultCrosshairPrefab => this._defaultCrosshairPrefab;

    [Client]
    public void SendConstructTurret(
      CharacterBody builder,
      Vector3 position,
      Quaternion rotation,
      MasterCatalog.MasterIndex masterIndex)
    {
      if (!NetworkClient.active)
        Debug.LogWarning((object) "[Client] function 'System.Void RoR2.CharacterBody::SendConstructTurret(RoR2.CharacterBody,UnityEngine.Vector3,UnityEngine.Quaternion,RoR2.MasterCatalog/MasterIndex)' called on server");
      else
        ClientScene.readyConnection.Send((short) 62, (MessageBase) new CharacterBody.ConstructTurretMessage()
        {
          builder = builder.gameObject,
          position = position,
          rotation = rotation,
          turretMasterIndex = (MasterCatalog.NetworkMasterIndex) masterIndex
        });
    }

    [NetworkMessageHandler(msgType = 62, server = true)]
    private static void HandleConstructTurret(NetworkMessage netMsg)
    {
      CharacterBody.ConstructTurretMessage constructTurretMessage = netMsg.ReadMessage<CharacterBody.ConstructTurretMessage>();
      if (!(bool) (UnityEngine.Object) constructTurretMessage.builder)
        return;
      CharacterBody component = constructTurretMessage.builder.GetComponent<CharacterBody>();
      if (!(bool) (UnityEngine.Object) component)
        return;
      CharacterMaster master = component.master;
      if (!(bool) (UnityEngine.Object) master)
        return;
      CharacterMaster characterMaster = new MasterSummon()
      {
        masterPrefab = MasterCatalog.GetMasterPrefab((MasterCatalog.MasterIndex) constructTurretMessage.turretMasterIndex),
        position = constructTurretMessage.position,
        rotation = constructTurretMessage.rotation,
        summonerBodyObject = component.gameObject,
        ignoreTeamMemberLimit = true,
        inventoryToCopy = master.inventory
      }.Perform();
      Deployable deployable = characterMaster.gameObject.AddComponent<Deployable>();
      deployable.onUndeploy = new UnityEvent();
      deployable.onUndeploy.AddListener(new UnityAction(characterMaster.TrueKill));
      master.AddDeployable(deployable, DeployableSlot.EngiTurret);
    }

    public int multiKillCount { get; private set; }

    [Server]
    public void AddMultiKill(int kills)
    {
      if (!NetworkServer.active)
      {
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::AddMultiKill(System.Int32)' called on client");
      }
      else
      {
        this.multiKillTimer = 1f;
        this.multiKillCount += kills;
        int num = (bool) (UnityEngine.Object) this.inventory ? this.inventory.GetItemCount(RoR2Content.Items.WarCryOnMultiKill) : 0;
        if (num <= 0 || this.multiKillCount < 4)
          return;
        this.AddTimedBuff(RoR2Content.Buffs.WarCryBuff, (float) (2.0 + 4.0 * (double) num));
      }
    }

    [Server]
    private void UpdateMultiKill(float deltaTime)
    {
      if (!NetworkServer.active)
      {
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::UpdateMultiKill(System.Single)' called on client");
      }
      else
      {
        this.multiKillTimer -= deltaTime;
        if ((double) this.multiKillTimer > 0.0)
          return;
        this.multiKillTimer = 0.0f;
        this.multiKillCount = 0;
      }
    }

    public Vector3 corePosition => !(bool) (UnityEngine.Object) this.coreTransform ? this.transform.position : this.coreTransform.position;

    public Vector3 footPosition
    {
      get
      {
        Vector3 position = this.transform.position;
        if ((bool) (UnityEngine.Object) this.characterMotor)
          position.y -= this.characterMotor.capsuleHeight * 0.5f;
        return position;
      }
    }

    public float radius { get; private set; }

    public Vector3 aimOrigin => !(bool) (UnityEngine.Object) this.aimOriginTransform ? this.corePosition : this.aimOriginTransform.position;

    public bool isElite { get; private set; }

    public bool isBoss => (bool) (UnityEngine.Object) this.master && this.master.isBoss;

    public bool isFlying => !(bool) (UnityEngine.Object) this.characterMotor || this.characterMotor.isFlying;

    [ClientRpc]
    public void RpcBark()
    {
      if (!(bool) (UnityEngine.Object) this.sfxLocator)
        return;
      int num = (int) Util.PlaySound(this.sfxLocator.barkSound, this.gameObject);
    }

    [Command]
    public void CmdRequestVehicleEjection()
    {
      if (!(bool) (UnityEngine.Object) this.currentVehicle)
        return;
      this.currentVehicle.EjectPassenger(this.gameObject);
    }

    public bool RollCrit() => (bool) (UnityEngine.Object) this.master && Util.CheckRoll(this.crit, this.master);

    [ClientRpc]
    private void RpcUsePreferredInitialStateType()
    {
      if (!this.hasEffectiveAuthority)
        return;
      this.SetBodyStateToPreferredInitialState();
    }

    public void SetBodyStateToPreferredInitialState()
    {
      if (!this.hasEffectiveAuthority)
      {
        if (!NetworkServer.active)
          return;
        this.CallRpcUsePreferredInitialStateType();
      }
      else
      {
        System.Type stateType = this.preferredInitialStateType.stateType;
        if (stateType == (System.Type) null || stateType == typeof (Uninitialized))
          return;
        EntityStateMachine.FindByCustomName(this.gameObject, "Body")?.SetState(EntityStateCatalog.InstantiateState(stateType));
      }
    }

    [Server]
    public void SetLoadoutServer(Loadout loadout)
    {
      if (!NetworkServer.active)
        Debug.LogWarning((object) "[Server] function 'System.Void RoR2.CharacterBody::SetLoadoutServer(RoR2.Loadout)' called on client");
      else
        this.skillLocator.ApplyLoadoutServer(loadout, this.bodyIndex);
    }

    public Run.FixedTimeStamp localStartTime { get; private set; } = Run.FixedTimeStamp.positiveInfinity;

    public bool isEquipmentActivationAllowed => !(bool) (UnityEngine.Object) this.currentVehicle || this.currentVehicle.isEquipmentActivationAllowed;

    static CharacterBody()
    {
      NetworkBehaviour.RegisterCommandDelegate(typeof (CharacterBody), CharacterBody.kCmdCmdAddTimedBuff, new NetworkBehaviour.CmdDelegate(CharacterBody.InvokeCmdCmdAddTimedBuff));
      CharacterBody.kCmdCmdUpdateSprint = -1006016914;
      NetworkBehaviour.RegisterCommandDelegate(typeof (CharacterBody), CharacterBody.kCmdCmdUpdateSprint, new NetworkBehaviour.CmdDelegate(CharacterBody.InvokeCmdCmdUpdateSprint));
      CharacterBody.kCmdCmdOnSkillActivated = 384138986;
      NetworkBehaviour.RegisterCommandDelegate(typeof (CharacterBody), CharacterBody.kCmdCmdOnSkillActivated, new NetworkBehaviour.CmdDelegate(CharacterBody.InvokeCmdCmdOnSkillActivated));
      CharacterBody.kCmdCmdRequestVehicleEjection = 1803737791;
      NetworkBehaviour.RegisterCommandDelegate(typeof (CharacterBody), CharacterBody.kCmdCmdRequestVehicleEjection, new NetworkBehaviour.CmdDelegate(CharacterBody.InvokeCmdCmdRequestVehicleEjection));
      CharacterBody.kRpcRpcBark = -76716871;
      NetworkBehaviour.RegisterRpcDelegate(typeof (CharacterBody), CharacterBody.kRpcRpcBark, new NetworkBehaviour.CmdDelegate(CharacterBody.InvokeRpcRpcBark));
      CharacterBody.kRpcRpcUsePreferredInitialStateType = 638695010;
      NetworkBehaviour.RegisterRpcDelegate(typeof (CharacterBody), CharacterBody.kRpcRpcUsePreferredInitialStateType, new NetworkBehaviour.CmdDelegate(CharacterBody.InvokeRpcRpcUsePreferredInitialStateType));
      NetworkCRC.RegisterBehaviour(nameof (CharacterBody), 0);
    }

    private void UNetVersion()
    {
    }

    protected static void InvokeCmdCmdAddTimedBuff(NetworkBehaviour obj, NetworkReader reader)
    {
      if (!NetworkServer.active)
        Debug.LogError((object) "Command CmdAddTimedBuff called on client.");
      else
        ((CharacterBody) obj).CmdAddTimedBuff((BuffIndex) reader.ReadInt32(), reader.ReadSingle());
    }

    protected static void InvokeCmdCmdUpdateSprint(NetworkBehaviour obj, NetworkReader reader)
    {
      if (!NetworkServer.active)
        Debug.LogError((object) "Command CmdUpdateSprint called on client.");
      else
        ((CharacterBody) obj).CmdUpdateSprint(reader.ReadBoolean());
    }

    protected static void InvokeCmdCmdOnSkillActivated(NetworkBehaviour obj, NetworkReader reader)
    {
      if (!NetworkServer.active)
        Debug.LogError((object) "Command CmdOnSkillActivated called on client.");
      else
        ((CharacterBody) obj).CmdOnSkillActivated((sbyte) reader.ReadPackedUInt32());
    }

    protected static void InvokeCmdCmdRequestVehicleEjection(
      NetworkBehaviour obj,
      NetworkReader reader)
    {
      if (!NetworkServer.active)
        Debug.LogError((object) "Command CmdRequestVehicleEjection called on client.");
      else
        ((CharacterBody) obj).CmdRequestVehicleEjection();
    }

    public void CallCmdAddTimedBuff(BuffIndex buffType, float duration)
    {
      if (!NetworkClient.active)
        Debug.LogError((object) "Command function CmdAddTimedBuff called on server.");
      else if (this.isServer)
      {
        this.CmdAddTimedBuff(buffType, duration);
      }
      else
      {
        NetworkWriter writer = new NetworkWriter();
        writer.Write((short) 0);
        writer.Write((short) 5);
        writer.WritePackedUInt32((uint) CharacterBody.kCmdCmdAddTimedBuff);
        writer.Write(this.GetComponent<NetworkIdentity>().netId);
        writer.Write((int) buffType);
        writer.Write(duration);
        this.SendCommandInternal(writer, 0, "CmdAddTimedBuff");
      }
    }

    public void CallCmdUpdateSprint(bool newIsSprinting)
    {
      if (!NetworkClient.active)
        Debug.LogError((object) "Command function CmdUpdateSprint called on server.");
      else if (this.isServer)
      {
        this.CmdUpdateSprint(newIsSprinting);
      }
      else
      {
        NetworkWriter writer = new NetworkWriter();
        writer.Write((short) 0);
        writer.Write((short) 5);
        writer.WritePackedUInt32((uint) CharacterBody.kCmdCmdUpdateSprint);
        writer.Write(this.GetComponent<NetworkIdentity>().netId);
        writer.Write(newIsSprinting);
        this.SendCommandInternal(writer, 0, "CmdUpdateSprint");
      }
    }

    public void CallCmdOnSkillActivated(sbyte skillIndex)
    {
      if (!NetworkClient.active)
        Debug.LogError((object) "Command function CmdOnSkillActivated called on server.");
      else if (this.isServer)
      {
        this.CmdOnSkillActivated(skillIndex);
      }
      else
      {
        NetworkWriter writer = new NetworkWriter();
        writer.Write((short) 0);
        writer.Write((short) 5);
        writer.WritePackedUInt32((uint) CharacterBody.kCmdCmdOnSkillActivated);
        writer.Write(this.GetComponent<NetworkIdentity>().netId);
        writer.WritePackedUInt32((uint) skillIndex);
        this.SendCommandInternal(writer, 0, "CmdOnSkillActivated");
      }
    }

    public void CallCmdRequestVehicleEjection()
    {
      if (!NetworkClient.active)
        Debug.LogError((object) "Command function CmdRequestVehicleEjection called on server.");
      else if (this.isServer)
      {
        this.CmdRequestVehicleEjection();
      }
      else
      {
        NetworkWriter writer = new NetworkWriter();
        writer.Write((short) 0);
        writer.Write((short) 5);
        writer.WritePackedUInt32((uint) CharacterBody.kCmdCmdRequestVehicleEjection);
        writer.Write(this.GetComponent<NetworkIdentity>().netId);
        this.SendCommandInternal(writer, 0, "CmdRequestVehicleEjection");
      }
    }

    protected static void InvokeRpcRpcBark(NetworkBehaviour obj, NetworkReader reader)
    {
      if (!NetworkClient.active)
        Debug.LogError((object) "RPC RpcBark called on server.");
      else
        ((CharacterBody) obj).RpcBark();
    }

    protected static void InvokeRpcRpcUsePreferredInitialStateType(
      NetworkBehaviour obj,
      NetworkReader reader)
    {
      if (!NetworkClient.active)
        Debug.LogError((object) "RPC RpcUsePreferredInitialStateType called on server.");
      else
        ((CharacterBody) obj).RpcUsePreferredInitialStateType();
    }

    public void CallRpcBark()
    {
      if (!NetworkServer.active)
      {
        Debug.LogError((object) "RPC Function RpcBark called on client.");
      }
      else
      {
        NetworkWriter writer = new NetworkWriter();
        writer.Write((short) 0);
        writer.Write((short) 2);
        writer.WritePackedUInt32((uint) CharacterBody.kRpcRpcBark);
        writer.Write(this.GetComponent<NetworkIdentity>().netId);
        this.SendRPCInternal(writer, 0, "RpcBark");
      }
    }

    public void CallRpcUsePreferredInitialStateType()
    {
      if (!NetworkServer.active)
      {
        Debug.LogError((object) "RPC Function RpcUsePreferredInitialStateType called on client.");
      }
      else
      {
        NetworkWriter writer = new NetworkWriter();
        writer.Write((short) 0);
        writer.Write((short) 2);
        writer.WritePackedUInt32((uint) CharacterBody.kRpcRpcUsePreferredInitialStateType);
        writer.Write(this.GetComponent<NetworkIdentity>().netId);
        this.SendRPCInternal(writer, 0, "RpcUsePreferredInitialStateType");
      }
    }

    public override void PreStartClient()
    {
    }

    private static class CommonAssets
    {
      public static SkillDef lunarUtilityReplacementSkillDef;
      public static SkillDef lunarPrimaryReplacementSkillDef;
      public static SkillDef lunarSecondaryReplacementSkillDef;
      public static SkillDef lunarSpecialReplacementSkillDef;
      public static NetworkSoundEventDef nullifiedBuffAppliedSound;
      public static NetworkSoundEventDef pulverizeBuildupBuffAppliedSound;
      public static NetworkSoundEventDef[] procCritAttackSpeedSounds;

      public static void Load()
      {
        CharacterBody.CommonAssets.nullifiedBuffAppliedSound = LegacyResourcesAPI.Load<NetworkSoundEventDef>("NetworkSoundEventDefs/nseNullifiedBuffApplied");
        CharacterBody.CommonAssets.pulverizeBuildupBuffAppliedSound = LegacyResourcesAPI.Load<NetworkSoundEventDef>("NetworkSoundEventDefs/nsePulverizeBuildupBuffApplied");
        CharacterBody.CommonAssets.procCritAttackSpeedSounds = new NetworkSoundEventDef[3]
        {
          LegacyResourcesAPI.Load<NetworkSoundEventDef>("NetworkSoundEventDefs/nseProcCritAttackSpeed1"),
          LegacyResourcesAPI.Load<NetworkSoundEventDef>("NetworkSoundEventDefs/nseProcCritAttackSpeed2"),
          LegacyResourcesAPI.Load<NetworkSoundEventDef>("NetworkSoundEventDefs/nseProcCritAttackSpeed3")
        };
        SkillCatalog.skillsDefined.CallWhenAvailable((Action) (() =>
        {
          CharacterBody.CommonAssets.lunarUtilityReplacementSkillDef = SkillCatalog.GetSkillDef(SkillCatalog.FindSkillIndexByName("LunarUtilityReplacement"));
          CharacterBody.CommonAssets.lunarPrimaryReplacementSkillDef = SkillCatalog.GetSkillDef(SkillCatalog.FindSkillIndexByName("LunarPrimaryReplacement"));
          CharacterBody.CommonAssets.lunarSecondaryReplacementSkillDef = SkillCatalog.GetSkillDef(SkillCatalog.FindSkillIndexByName("LunarSecondaryReplacement"));
          CharacterBody.CommonAssets.lunarSpecialReplacementSkillDef = SkillCatalog.GetSkillDef(SkillCatalog.FindSkillIndexByName("LunarDetonatorSpecialReplacement"));
        }));
      }
    }

    private class TimedBuff
    {
      public BuffIndex buffIndex;
      public float timer;
    }

    [System.Flags]
    public enum BodyFlags : uint
    {
      None = 0,
      IgnoreFallDamage = 1,
      Mechanical = 2,
      Masterless = 4,
      ImmuneToGoo = 8,
      ImmuneToExecutes = 16, // 0x00000010
      SprintAnyDirection = 32, // 0x00000020
      ResistantToAOE = 64, // 0x00000040
      HasBackstabPassive = 128, // 0x00000080
      HasBackstabImmunity = 256, // 0x00000100
      OverheatImmune = 512, // 0x00000200
      Void = 1024, // 0x00000400
      ImmuneToVoidDeath = 2048, // 0x00000800
    }

    public class ItemBehavior : MonoBehaviour
    {
      public CharacterBody body;
      public int stack;
    }

    public class AffixHauntedBehavior : CharacterBody.ItemBehavior
    {
      private GameObject affixHauntedWard;

      private void FixedUpdate()
      {
        if (!NetworkServer.active)
          return;
        bool flag = this.stack > 0;
        if ((bool) (UnityEngine.Object) this.affixHauntedWard == flag)
          return;
        if (flag)
        {
          this.affixHauntedWard = UnityEngine.Object.Instantiate<GameObject>(LegacyResourcesAPI.Load<GameObject>("Prefabs/NetworkedObjects/AffixHauntedWard"));
          this.affixHauntedWard.GetComponent<TeamFilter>().teamIndex = this.body.teamComponent.teamIndex;
          this.affixHauntedWard.GetComponent<BuffWard>().Networkradius = 30f + this.body.radius;
          this.affixHauntedWard.GetComponent<NetworkedBodyAttachment>().AttachToGameObjectAndSpawn(this.body.gameObject);
        }
        else
        {
          UnityEngine.Object.Destroy((UnityEngine.Object) this.affixHauntedWard);
          this.affixHauntedWard = (GameObject) null;
        }
      }

      private void OnDisable()
      {
        if (!(bool) (UnityEngine.Object) this.affixHauntedWard)
          return;
        UnityEngine.Object.Destroy((UnityEngine.Object) this.affixHauntedWard);
      }
    }

    public class QuestVolatileBatteryBehaviorServer : CharacterBody.ItemBehavior
    {
      private NetworkedBodyAttachment attachment;

      private void Start()
      {
        this.attachment = UnityEngine.Object.Instantiate<GameObject>(LegacyResourcesAPI.Load<GameObject>("Prefabs/NetworkedObjects/QuestVolatileBatteryAttachment")).GetComponent<NetworkedBodyAttachment>();
        this.attachment.AttachToGameObjectAndSpawn(this.body.gameObject);
      }

      private void OnDestroy()
      {
        if (!(bool) (UnityEngine.Object) this.attachment)
          return;
        UnityEngine.Object.Destroy((UnityEngine.Object) this.attachment.gameObject);
        this.attachment = (NetworkedBodyAttachment) null;
      }
    }

    public class TimeBubbleItemBehaviorServer : CharacterBody.ItemBehavior
    {
      private void OnDestroy()
      {
        if (!(bool) (UnityEngine.Object) this.body.timeBubbleWardInstance)
          return;
        UnityEngine.Object.Destroy((UnityEngine.Object) this.body.timeBubbleWardInstance);
      }
    }

    public class ElementalRingsBehavior : CharacterBody.ItemBehavior
    {
      private void OnDisable()
      {
        if (!(bool) (UnityEngine.Object) this.body)
          return;
        if (this.body.HasBuff(RoR2Content.Buffs.ElementalRingsReady))
          this.body.RemoveBuff(RoR2Content.Buffs.ElementalRingsReady);
        if (!this.body.HasBuff(RoR2Content.Buffs.ElementalRingsCooldown))
          return;
        this.body.RemoveBuff(RoR2Content.Buffs.ElementalRingsCooldown);
      }

      private void FixedUpdate()
      {
        bool flag1 = this.body.HasBuff(RoR2Content.Buffs.ElementalRingsCooldown);
        bool flag2 = this.body.HasBuff(RoR2Content.Buffs.ElementalRingsReady);
        if (!flag1 && !flag2)
          this.body.AddBuff(RoR2Content.Buffs.ElementalRingsReady);
        if (!(flag2 & flag1))
          return;
        this.body.RemoveBuff(RoR2Content.Buffs.ElementalRingsReady);
      }
    }

    public class AffixEchoBehavior : CharacterBody.ItemBehavior
    {
      private DeployableMinionSpawner echoSpawner1;
      private DeployableMinionSpawner echoSpawner2;
      private CharacterSpawnCard spawnCard;
      private List<CharacterMaster> spawnedEchoes = new List<CharacterMaster>();

      private void FixedUpdate() => this.spawnCard.nodeGraphType = this.body.isFlying ? MapNodeGroup.GraphType.Air : MapNodeGroup.GraphType.Ground;

      private void Awake() => this.enabled = false;

      private void OnEnable()
      {
        MasterCatalog.MasterIndex masterIndexForBody = MasterCatalog.FindAiMasterIndexForBody(this.body.bodyIndex);
        this.spawnCard = ScriptableObject.CreateInstance<CharacterSpawnCard>();
        this.spawnCard.prefab = MasterCatalog.GetMasterPrefab(masterIndexForBody);
        this.spawnCard.inventoryToCopy = this.body.inventory;
        this.spawnCard.equipmentToGrant = new EquipmentDef[1];
        this.spawnCard.itemsToGrant = new ItemCountPair[1]
        {
          new ItemCountPair()
          {
            itemDef = RoR2Content.Items.SummonedEcho,
            count = 1
          }
        };
        this.CreateSpawners();
      }

      private void OnDisable()
      {
        UnityEngine.Object.Destroy((UnityEngine.Object) this.spawnCard);
        this.spawnCard = (CharacterSpawnCard) null;
        for (int index = this.spawnedEchoes.Count - 1; index >= 0; --index)
        {
          if ((bool) (UnityEngine.Object) this.spawnedEchoes[index])
            this.spawnedEchoes[index].TrueKill();
        }
        this.DestroySpawners();
      }

      private void CreateSpawners()
      {
        Xoroshiro128Plus rng = new Xoroshiro128Plus(Run.instance.seed ^ (ulong) this.GetInstanceID());
        CreateSpawner(ref this.echoSpawner1, DeployableSlot.RoboBallRedBuddy, (SpawnCard) this.spawnCard);
        CreateSpawner(ref this.echoSpawner2, DeployableSlot.RoboBallGreenBuddy, (SpawnCard) this.spawnCard);

        void CreateSpawner(
          ref DeployableMinionSpawner buddySpawner,
          DeployableSlot deployableSlot,
          SpawnCard spawnCard)
        {
          buddySpawner = new DeployableMinionSpawner(this.body.master, deployableSlot, rng)
          {
            respawnInterval = 30f,
            spawnCard = spawnCard
          };
          buddySpawner.onMinionSpawnedServer += new Action<SpawnCard.SpawnResult>(this.OnMinionSpawnedServer);
        }
      }

      private void DestroySpawners()
      {
        this.echoSpawner1?.Dispose();
        this.echoSpawner1 = (DeployableMinionSpawner) null;
        this.echoSpawner2?.Dispose();
        this.echoSpawner2 = (DeployableMinionSpawner) null;
      }

      private void OnMinionSpawnedServer(SpawnCard.SpawnResult spawnResult)
      {
        GameObject spawnedInstance = spawnResult.spawnedInstance;
        if (!(bool) (UnityEngine.Object) spawnedInstance)
          return;
        CharacterMaster spawnedMaster = spawnedInstance.GetComponent<CharacterMaster>();
        if (!(bool) (UnityEngine.Object) spawnedMaster)
          return;
        this.spawnedEchoes.Add(spawnedMaster);
        OnDestroyCallback.AddCallback(spawnedMaster.gameObject, (Action<OnDestroyCallback>) (_ => this.spawnedEchoes.Remove(spawnedMaster)));
      }
    }

    private static class AssetReferences
    {
      public static GameObject engiShieldTempEffectPrefab;
      public static GameObject bucklerShieldTempEffectPrefab;
      public static GameObject slowDownTimeTempEffectPrefab;
      public static GameObject crippleEffectPrefab;
      public static GameObject tonicBuffEffectPrefab;
      public static GameObject weakTempEffectPrefab;
      public static GameObject energizedTempEffectPrefab;
      public static GameObject barrierTempEffectPrefab;
      public static GameObject nullifyStack1EffectPrefab;
      public static GameObject nullifyStack2EffectPrefab;
      public static GameObject nullifyStack3EffectPrefab;
      public static GameObject regenBoostEffectPrefab;
      public static GameObject elephantDefenseEffectPrefab;
      public static GameObject healingDisabledEffectPrefab;
      public static GameObject noCooldownEffectPrefab;
      public static GameObject doppelgangerEffectPrefab;
      public static GameObject deathmarkEffectPrefab;
      public static GameObject crocoRegenEffectPrefab;
      public static GameObject mercExposeEffectPrefab;
      public static GameObject lifestealOnHitEffectPrefab;
      public static GameObject teamWarCryEffectPrefab;
      public static GameObject randomDamageEffectPrefab;
      public static GameObject lunarGolemShieldEffectPrefab;
      public static GameObject warbannerEffectPrefab;
      public static GameObject teslaFieldEffectPrefab;
      public static GameObject lunarSecondaryRootEffectPrefab;
      public static GameObject lunarDetonatorEffectPrefab;
      public static GameObject fruitingEffectPrefab;
      public static GameObject mushroomVoidTempEffectPrefab;
      public static GameObject bearVoidTempEffectPrefab;
      public static GameObject outOfCombatArmorEffectPrefab;
      public static GameObject voidFogMildEffectPrefab;
      public static GameObject voidFogStrongEffectPrefab;
      public static GameObject voidJailerSlowEffectPrefab;
      public static GameObject voidRaidcrabWardWipeFogEffectPrefab;
      public static GameObject permanentDebuffEffectPrefab;

      public static void Resolve()
      {
        CharacterBody.AssetReferences.engiShieldTempEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/EngiShield");
        CharacterBody.AssetReferences.bucklerShieldTempEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/BucklerDefense");
        CharacterBody.AssetReferences.slowDownTimeTempEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/SlowDownTime");
        CharacterBody.AssetReferences.crippleEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/CrippleEffect");
        CharacterBody.AssetReferences.tonicBuffEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/TonicBuffEffect");
        CharacterBody.AssetReferences.weakTempEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/WeakEffect");
        CharacterBody.AssetReferences.energizedTempEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/EnergizedEffect");
        CharacterBody.AssetReferences.barrierTempEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/BarrierEffect");
        CharacterBody.AssetReferences.regenBoostEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/RegenBoostEffect");
        CharacterBody.AssetReferences.elephantDefenseEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/ElephantDefense");
        CharacterBody.AssetReferences.healingDisabledEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/HealingDisabledEffect");
        CharacterBody.AssetReferences.noCooldownEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/NoCooldownEffect");
        CharacterBody.AssetReferences.doppelgangerEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/DoppelgangerEffect");
        CharacterBody.AssetReferences.nullifyStack1EffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/NullifyStack1Effect");
        CharacterBody.AssetReferences.nullifyStack2EffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/NullifyStack2Effect");
        CharacterBody.AssetReferences.nullifyStack3EffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/NullifyStack3Effect");
        CharacterBody.AssetReferences.deathmarkEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/DeathMarkEffect");
        CharacterBody.AssetReferences.crocoRegenEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/CrocoRegenEffect");
        CharacterBody.AssetReferences.mercExposeEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/MercExposeEffect");
        CharacterBody.AssetReferences.lifestealOnHitEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/LifeStealOnHitAura");
        CharacterBody.AssetReferences.teamWarCryEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/TeamWarCryAura");
        CharacterBody.AssetReferences.lunarGolemShieldEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/LunarDefense");
        CharacterBody.AssetReferences.randomDamageEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/RandomDamageBuffEffect");
        CharacterBody.AssetReferences.warbannerEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/WarbannerBuffEffect");
        CharacterBody.AssetReferences.teslaFieldEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/TeslaFieldBuffEffect");
        CharacterBody.AssetReferences.lunarSecondaryRootEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/LunarSecondaryRootEffect");
        CharacterBody.AssetReferences.lunarDetonatorEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/LunarDetonatorEffect");
        CharacterBody.AssetReferences.fruitingEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/FruitingEffect");
        CharacterBody.AssetReferences.mushroomVoidTempEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/MushroomVoidEffect");
        CharacterBody.AssetReferences.bearVoidTempEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/BearVoidEffect");
        CharacterBody.AssetReferences.outOfCombatArmorEffectPrefab = Addressables.LoadAssetAsync<GameObject>((object) "RoR2/DLC1/OutOfCombatArmor/OutOfCombatArmorEffect.prefab").WaitForCompletion();
        CharacterBody.AssetReferences.voidFogMildEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/VoidFogMildEffect");
        CharacterBody.AssetReferences.voidFogStrongEffectPrefab = LegacyResourcesAPI.Load<GameObject>("Prefabs/TemporaryVisualEffects/VoidFogStrongEffect");
        CharacterBody.AssetReferences.voidRaidcrabWardWipeFogEffectPrefab = Addressables.LoadAssetAsync<GameObject>((object) "RoR2/DLC1/VoidRaidCrab/VoidRaidCrabWardWipeFogEffect.prefab").WaitForCompletion();
        CharacterBody.AssetReferences.voidJailerSlowEffectPrefab = Addressables.LoadAssetAsync<GameObject>((object) "RoR2/DLC1/VoidJailer/VoidJailerTetherDebuff.prefab").WaitForCompletion();
      }
    }

    private class ConstructTurretMessage : MessageBase
    {
      public GameObject builder;
      public Vector3 position;
      public Quaternion rotation;
      public MasterCatalog.NetworkMasterIndex turretMasterIndex;

      public override void Serialize(NetworkWriter writer)
      {
        writer.Write(this.builder);
        writer.Write(this.position);
        writer.Write(this.rotation);
        GeneratedNetworkCode._WriteNetworkMasterIndex_MasterCatalog(writer, this.turretMasterIndex);
      }

      public override void Deserialize(NetworkReader reader)
      {
        this.builder = reader.ReadGameObject();
        this.position = reader.ReadVector3();
        this.rotation = reader.ReadQuaternion();
        this.turretMasterIndex = GeneratedNetworkCode._ReadNetworkMasterIndex_MasterCatalog(reader);
      }
    }

    [Serializable]
    public class CharacterBodyUnityEvent : UnityEvent<CharacterBody>
    {
    }
  }
}
